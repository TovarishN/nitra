using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Runtime;
using Nitra.Typing;
using Nitra.ProjectSystem;

using System;
using System.Reflection;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public sealed class CompilingNitraProject : NitraProject
  {
    public this()
    {
      base(NemerleCompilerMessages())
    }

    public ErrorCount : int { get { (CompilerMessages :> NemerleCompilerMessages).ErrorCount } }

    private mutable _environment : EmitterEnvironment;

    public Environment : EmitterEnvironment
    {
      get
      {
        when (_environment : object == null)
          _environment = EmitterEnvironment(ManagerClass.Instance, this);
        _environment
      }
    }

    public override Files : Seq[File] { get { throw NotImplementedException() } }

    public override Init(referencedAssemblies : Seq[AssemblyName]) : void
    {
      base.Init(referencedAssemblies);
      _environment = null;
      _fakeFiles.Clear();
    }

    public override GetNemerleType(symbol : Symbol) : FixedType
    {
      | ruleSymbol   is RuleSymbol   => Environment.GetParseTreeType(ruleSymbol)
      | astSymbol    is AstSymbol    => Environment.GetAstType(astSymbol)
      | symbolSymbol is SymbolSymbol => Environment.GetSymbolClass(symbolSymbol)
      | _ => assert(false, $"Cannot get Nemerle type for symbol '$symbol'")
    }

    private _fakeFiles : SCG.Dictionary[int, FakeNemerleFile] = SCG.Dictionary();

    public override MakeFakeNitraLocation(location : Nemerle.Compiler.Location) : Nitra.Location
    {
      mutable file;
      unless (_fakeFiles.TryGetValue(location.FileIndex, out file))
      {
        file = FakeNemerleFile(this, location.FileIndex);
        _fakeFiles.Add(location.FileIndex, file);
      }
      Nitra.Location(file, 0)
    }
  }
}
