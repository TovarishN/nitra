using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class BaseAstEmitter
  {
    public abstract TypeCompiler : NTypeCompiler      { get }
    public abstract Environment  : EmitterEnvironment { get }

    protected DefineInterfaceDependentProperty(propertySymbol : DependentPropertySymbol, tb : TypeBuilder, isOverride : bool) : void
    {
      def propertyType = TypeCompiler.CompileDependentPropertyType(propertySymbol);
      def attribute    = MakeDependentPropertyAttribute(propertySymbol, -1);
      def mods         = AttributesAndModifiers(if (isOverride) NemerleModifiers.New else NemerleModifiers.None, [attribute]);
      tb.Define(<[ decl: ..$mods $(propertySymbol.Name : usesite) : $(propertyType : typed) { get; set; } ]>);
      unless (isOverride)
        tb.Define(<[ decl: $(GetIsEvaluatedPropertyName(propertySymbol) : usesite) : bool { get; } ]>);
    }

    protected DefineDependentProperty(tb : TypeBuilder, propertyRef : DependentPropertyRef.Compiling, modifiers : NemerleModifiers, overrideSetter : bool = true) : void
    {
      def propertyType     = TypeCompiler.CompileDependentPropertyType(propertyRef.Symbol);
      def backingFieldName = Util.tmpname(propertyRef.Symbol.Name);
      Util.locate(propertyRef.Symbol.FirstLocation.NLocation(),
      {
        tb.Define(<[ decl:
          [RecordIgnore] private mutable $(backingFieldName : usesite) : $(propertyType : typed)
        ]>);

        def mods          = AttributesAndModifiers(modifiers, [MakeDependentPropertyAttribute(propertyRef.Symbol, propertyRef.Index)]);
        tb.Define(<[ decl:
          ..$mods $(propertyRef.Symbol.Name : usesite) : $(propertyType : typed)
          {
            get
            {
              unless($(propertyRef.Bit.Read()))
                $(MakeAccessAssertion(propertyRef));
              this.$(backingFieldName : usesite)
            }
            set
            {
              unless ($(propertyRef.Bit.Read()))
              {
                this.$(backingFieldName : usesite) = value;
                $(propertyRef.Bit.Set());
              }
            }
          }
        ]>);

        def isEvaluatedName = GetIsEvaluatedPropertyName(propertyRef.Symbol);
        def isEvaluatedMods = AttributesAndModifiers(modifiers, []);
        tb.Define(<[ decl:
          ..$isEvaluatedMods $(isEvaluatedName : usesite) : bool
          {
            get { $(propertyRef.Bit.Read()) }
          }
        ]>);

        when (overrideSetter)
          DefineDependenPropertyOverrideSetter(tb, propertyRef.Symbol);
      });
    }

    protected DefineDependenPropertyOverrideSetter(tb : TypeBuilder, property : DependentPropertySymbol) : void
    {
      when (property.OverrideProperty is SymbolRef.Some(originalProperty))
      {
        def originalType   = TypeCompiler.CompileDependentPropertyType(originalProperty :> DependentPropertySymbol);
        def overriddenType = TypeCompiler.CompileDependentPropertyType(property);

        def setterName = "set_" + property.Name;
        def decl = <[ decl:
          $(Util.tmpname(setterName) : usesite)(value : $(originalType : typed)) : void
          {
            this.$(property.Name : usesite) = value :> $(overriddenType : typed)
          }
        ]>;

        decl.implemented = [<[ $(Environment.Project.GetNemerleType(originalProperty.PropertyContainer) : typed).$(setterName : usesite) ]>];

        foreach (container in property.PropertyContainer.GetAncestors())
        {
          when (container.LookupProperty(property.Name) is VSome(candidateProperty)             when candidateProperty.PropertyContainer : object == container)
          when (candidateProperty.OverrideProperty is SymbolRef.Some(candidateOriginalProperty) when originalProperty : object == candidateOriginalProperty)
            decl.implemented ::= <[ $(Environment.Project.GetNemerleType(container) : typed).$(setterName : usesite) ]>;
        }

        tb.Define(decl)
      }
    }

    protected static GetIsEvaluatedPropertyName(propertySymbol : DependentPropertySymbol) : string
    {
      "Is" + propertySymbol.Name + "Evaluated"
    }

    protected static MakeAccessAssertion(propertyRef : DependentPropertyRef) : PExpr
    {
      def assertMessage = $"Property '$(propertyRef.Symbol.FullName)' is not set'";
      <[ assert(false, $(assertMessage : string)); ]>
    }

    protected static MakeDependentPropertyAttribute(propertySymbol : DependentPropertySymbol, index : int) : PExpr
    {
      <[ Nitra.Internal.DependentPropertyAttribute($(propertySymbol.FullName : string), $(index : int), $(propertySymbol.Direction == DependentPropertyDirection.Out)) ]>
    }

    protected static DefineResetPropertiesMethod(tb : TypeBuilder, ambiguousTb : TypeBuilder, inheritedBitsCount : int = 0) : void
    {
      assert(tb != null || ambiguousTb != null);

      def makeBody(tb : TypeBuilder) : PExpr
      {
        def fields = tb.GetBitFieldManager().GetFields();
        if (fields.Length > 0)
        {
          def body = SCG.List();
          when (inheritedBitsCount > 0)
            body.Add(<[ base.ResetProperties() ]>);

          foreach (field in fields)
            body.Add(<[ this.$(field : usesite) = 0 ]>);

          <[ { ..$body } ]>
        }
        else null
      }

      def defineAmbiguousMethod(body)
      {
        ambiguousTb.Define(<[ decl:
          public override ResetProperties() : void
          {
            if (this.IsAmbiguous)
              Nitra.Internal.AstUtils.ResetAmbiguitiesProperties(this)
            else
              $body
          }
        ]>)
      }

      if (tb != null)
      {
        def body = makeBody(tb);
        when (body != null)
          tb.Define(<[ decl: public override ResetProperties() : void $body ]>);

        when (ambiguousTb != null)
          defineAmbiguousMethod(<[ base.ResetProperties() ]>);
      }
      else
        defineAmbiguousMethod(makeBody(ambiguousTb) ?? <[ () ]>);
    }

    protected static DefineIsAllPropertiesEvaluatedProperty(tb : TypeBuilder, ambiguousTb : TypeBuilder, inheritedBitsCount : int = 0) : void
    {
      assert(tb != null || ambiguousTb != null);

      def makeBody(tb : TypeBuilder) : PExpr
      {
        def fieldManager = tb.GetBitFieldManager();
        def fields       = fieldManager.GetFields();
        if (fields.Length > 0)
        {
          mutable acc =
            if (inheritedBitsCount > 0)
              <[ base.IsAllPropertiesEvaluated ]>
            else
              <[ true ]>;

          def lastIndex = fields.Length - 1;
          foreach (field in fields with index)
            acc =
              if (index == lastIndex)
                <[ $acc && (this.$(field : usesite) == $(fieldManager.LastFieldMask)) ]>
              else
                <[ $acc && (this.$(field : usesite) == $(BitFieldManager.FullFieldMask)) ]>;

          acc
        }
        else null
      }

      def defineAmbiguousMethod(body)
      {
        ambiguousTb.Define(<[ decl: 
          public override IsAllPropertiesEvaluated : bool
          {
            get
            {
              if (this.IsAmbiguous)
                Ambiguities[0].IsAllPropertiesEvaluated
              else
                $body
            }
          }
        ]>)
      }

      if (tb != null)
      {
        def body = makeBody(tb);
        when (body != null)
          tb.Define(<[ decl: public override IsAllPropertiesEvaluated : bool { get { $body } } ]>);

        when (ambiguousTb != null)
          defineAmbiguousMethod(<[ base.IsAllPropertiesEvaluated ]>)
      }
      else
        defineAmbiguousMethod(makeBody(ambiguousTb) ?? <[ true ]>)
    }

    protected static DefineIsPropertyEvaluatedMethod(tb : TypeBuilder, modifiers : NemerleModifiers) : void
    {
      def body = MakeIsPropertyEvaluatedBody(tb);
      def mods = AttributesAndModifiers(NemerleModifiers.Public %| modifiers, []);
      tb.Define(<[ decl:
        ..$mods IsPropertyEvaluated(index : int) : bool
        {
          _ = index;
          unchecked ($body)
        }
      ]>);
    }

    private static MakeIsPropertyEvaluatedBody(tb : TypeBuilder) : PExpr
    {
      def     fields = tb.GetBitFieldManager().GetFields();
      mutable body   = <[ throw System.ArgumentOutOfRangeException("index") ]>;
      for (mutable i = fields.Length; i > 0; --i)
      {
        body = <[
          if (index < $(i * BitFieldManager.BitFieldSize))
            this.$(fields[i - 1] : usesite) %&& (1 << (index % $(BitFieldManager.BitFieldSize)))
          else
            $body
        ]>
      }
      body
    }

    protected static GenerateHasValueCheck(obj : TExpr, propertyRef : DependentPropertyRef) : PExpr
    {
      GenerateHasValueCheck(<[ $(obj : typed) ]>, propertyRef)
    }

    protected static GenerateHasValueCheck(obj : PExpr, propertyRef : DependentPropertyRef) : PExpr
    {
      if (propertyRef is Compiling(bit) when IsThis(obj))
        bit.Read()
      else
        CallIsPropertyEvaluated(obj, propertyRef)
    }

    protected static GenerateHasValueCheck(properties : SCG.List[TExpr * DependentPropertyRef]) : PExpr
    {
      mutable other;
      def bitsToCheck = LightList();
      foreach ((obj, propertyRef) in properties)
      {
        if (propertyRef is Compiling(bit) when IsThis(obj))
          bitsToCheck.Add(bit)
        else
          PExprUtils.CombineAnd(ref other, CallIsPropertyEvaluated(<[ $(obj : typed) ]>, propertyRef))
      }

      mutable result;
      match (bitsToCheck.Count)
      {
        | 0 => ()
        | 1 => result = bitsToCheck.FirstItem.Read()
        | _ => result = BitField.CheckAll(bitsToCheck.ToList())
      }

      when (other : object != null)
        PExprUtils.CombineAnd(ref result, other);

      result ?? <[ true ]>
    }

    private static CallIsPropertyEvaluated(obj : PExpr, propertyRef : DependentPropertyRef) : PExpr
    {
      if (propertyRef.Index >= 0)
        <[ $obj.IsPropertyEvaluated($(propertyRef.Index : int)) ]>
      else
        <[ $obj.$(GetIsEvaluatedPropertyName(propertyRef.Symbol) : usesite) ]>
    }

    private static IsThis(e : PExpr) : bool
    {
      | PExpr.This     => true
      | PExpr.Typed(e) => IsThis(e)
      | _              => false
    }

    private static IsThis(e : TExpr) : bool
    {
      | TExpr.This            => true
      | TExpr.DebugInfo(e, _) => IsThis(e)
      | _                     => false
    }
  }
}
