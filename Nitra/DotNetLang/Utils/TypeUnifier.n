using Nitra.Declarations;

using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace DotNet
{
  public class TypeUnifier : Nitra.Declarations.TypeUnifier
  {
    public static InitInstance() : void
    {
      Instance = TypeUnifier();
    }

    protected override Unwrap(t : TypeSymbol) : TypeSymbol
    {
      | alias is TypeAliasSymbol when alias.IsReplacementEvaluated =>
        def replacement = alias.Replacement;
        when (replacement.IsSymbolEvaluated)
          when (replacement.Symbol is TypeSymbol as type)
            return Unwrap(type);
            
        base.Unwrap(t)
        
      | _ => base.Unwrap(t)
    }

    
    protected override IsSubtypeUnwraped(subtype : TypeSymbol, supertype : TypeSymbol) : bool
    {
      when (subtype.Equals(supertype))
        return true;
      // TODO: оптимизировать рабту с object
      //when (supertype : object == context.GetVoidType())
      //  return true;

      when (subtype is SupportsInheritanceTypeSymbol(IsBaseTypeSetEvaluated=true, BaseTypeSet=baseTypeSet))
        return baseTypeSet.AncestorTypes.Contains(supertype);

      false
    }
  }
}
