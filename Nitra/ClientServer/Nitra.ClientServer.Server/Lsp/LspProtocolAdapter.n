using Nitra.ClientServer.Messages;
using Nitra.ClientServer.Server.ProjectSystem;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nitra.Logging;

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.IO;
using System.Threading;
using System.Xml.Linq;

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Microsoft.VisualStudio.LanguageServer.Protocol;

using LSP      = Microsoft.VisualStudio.LanguageServer.Protocol;
using Messages = Nitra.ClientServer.Messages;

namespace Nitra.ClientServer.Server.Lsp
{
  internal class LspProtocolAdapter : IProtocolAdapter
  {
    private static mutable _tagCounter  : int;

    private _requestTable             : ConcurrentDictionary[uint, object * Delegate] = ConcurrentDictionary();
    private _fileToCompilerMessageMap : ConcurrentDictionary[FileId, array[array[Diagnostic]]] = ConcurrentDictionary();

    private mutable _router     : Router;
    private mutable _input      : Stream;
    private mutable _output     : Stream;
    private mutable _reader     : LspReader;
    private mutable _writer     : LspWriter;
    private mutable _solution   : LspSolution;

    private mutable pendingCompletionId : object;

    public IsLsp : bool { get true; }

    public Connect([NotNull] router : Router) : void
    {
      _router = router;
      InitChangeLog();

      _input = Console.OpenStandardInput();
      _output = Console.OpenStandardOutput();

      _reader = LspReader(_input);
      _writer = LspWriter(_output);

      _reader.UnknownRequestHandler += UnknownHandler;

      _reader.RegisterHandler("$/cancelRequest",                       CancelRequestHandler);
      _reader.RegisterHandler(Methods.Initialize,                      InitializeHandler);
      _reader.RegisterHandler(Methods.Initialized,                     InitializedHandler);
      _reader.RegisterHandler(Methods.Shutdown,                        ShutdownHandler);
      _reader.RegisterHandler(Methods.Exit,                            ExitHandler);
      _reader.RegisterHandler(Methods.WorkspaceDidChangeConfiguration, WorkspaceDidChangeConfigurationHandler);
      _reader.RegisterHandler(Methods.TextDocumentDidOpen,             TextDocumentDidOpenHandler);
      _reader.RegisterHandler(Methods.TextDocumentDidClose,            TextDocumentDidCloseHandler);
      _reader.RegisterHandler(Methods.TextDocumentDidChange,           TextDocumentDidChangeHandler);
      _reader.RegisterHandler(Methods.TextDocumentDidSave,             TextDocumentDidSaveHandler);
      _reader.RegisterHandler(Methods.TextDocumentDocumentHighlight,   TextDocumentDocumentHighlightHandler);
      _reader.RegisterHandler(Methods.TextDocumentReferences,          TextDocumentReferencesHandler);
      _reader.RegisterHandler(Methods.TextDocumentHover,               TextDocumentHoverHandler);
      _reader.RegisterHandler(Methods.TextDocumentCompletion,          TextDocumentCompletionHandler);
      _reader.RegisterHandler(Methods.TextDocumentDefinition,          TextDocumentDefinition);
    }

    public Dispose() : void
    {
      _input?.Dispose();
      _output?.Dispose();
    }

    public ProcessMessage() : void
    {
      _reader.ReadRequests();
      _router.AddMessage(ClientMessage.Shutdown());
    }

    public Send(message : ServerMessage) : void
    {
      | FindSymbolDefinitions(_solutionId, _span, symbols, tag) => CompleteRequest(tag, symbols)
      | FindSymbolReferences (_solutionId, _span, symbols, tag) => CompleteRequest(tag, symbols)
      | _ => ()
    }

    public Send(message : AsyncServerMessage) : void
    {
      | FindSymbolReferences(_span, symbols, tag) => CompleteRequest(tag, symbols)
      | Hint(text, _span, tag)                    => CompleteRequest(tag, text)
      | CompleteWord(_span, completionList)       => CompleteWord(message.FileId, completionList, Interlocked.Exchange(ref pendingCompletionId, null))
      //| ProjectLoadingMessages  (projectId, messages) => SendCompilerMessagesToClient(projectId, message.FileId, messages);
      | ParsingMessages         (projectId, messages) => lock (_locker) SendCompilerMessagesToClient(projectId, message.FileId, messages, pass=0);
      | MappingMessages         (projectId, messages) => lock (_locker) SendCompilerMessagesToClient(projectId, message.FileId, messages, pass=1);
      | SemanticAnalysisMessages(projectId, messages) => lock (_locker) SendCompilerMessagesToClient(projectId, message.FileId, messages, pass=2);
      | _ => ()
    }

    private _locker : object = object();

    private SendCompilerMessagesToClient(_projectId : ProjectId, fileId : FileId, messages : array[CompilerMessage], pass : int) : void
    {
      when (fileId == FileId.Invalid)
        return;

      def diagnosticsPass =
        if (pass == 0)
        {
          def x = array[array(0), array(0), array(0)];
          _fileToCompilerMessageMap[fileId] = x;
          x
        }
        else
          _fileToCompilerMessageMap[fileId];

      def diagnostics = List();
      def uri         = _solution.GetUri(fileId);
      foreach (m in messages)
      {
        def severity =
          match (m.Type)
          {
            | FatalError => DiagnosticSeverity.Error
            | Error      => DiagnosticSeverity.Error
            | Warning    => DiagnosticSeverity.Warning
            | Hint       => DiagnosticSeverity.Hint
          };
        def loc = m.Location;
        diagnostics.Add(Diagnostic() <-
        {
          Range = Convert(loc.Range);
          Severity = severity;
          Code = if (m.Number < 0) null else m.Number.ToString();
          Message = m.Text;
          // Source = ???
        });
      }

      diagnosticsPass[pass] = diagnostics.ToArray();

      diagnostics.Clear();
      diagnostics.AddRange(diagnosticsPass[0]);
      diagnostics.AddRange(diagnosticsPass[1]);
      diagnostics.AddRange(diagnosticsPass[2]);

      def @params = PublishDiagnosticParams() <- { Uri = uri; Diagnostics = diagnostics.ToArray(); };
      WriteNotification(Methods.TextDocumentPublishDiagnostics, @params);
      Log.Message($"LSP $(Methods.TextDocumentPublishDiagnosticsName) fileId=$fileId pass=$pass messages.Length=$(messages.Length) diagnostics", ConsoleColor.Cyan);
    }

    private UnknownHandler(method : string, id : object) : void
    {
      when (id != null)
        WriteError(id, LspErrorCode.MethodNotFound, method)
    }

    private CancelRequestHandler(_p : CancelParams) : void
    {
    }

    private InitializeHandler(p : InitializeParams, id : object) : void
    {
      def result =
        InitializeResult() <-
        {
          Capabilities = ServerCapabilities() <-
          {
            TextDocumentSync = TextDocumentSyncOptions() <-
              {
                OpenClose = true;
                Change = TextDocumentSyncKind.Incremental;
                Save = SaveOptions() <- { IncludeText = false }
              };
            DefinitionProvider = true;
            ReferencesProvider = true;
            DocumentHighlightProvider = true;
            CompletionProvider = CompletionOptions() <- { ResolveProvider = false };
            HoverProvider = true
          }
        };

      when (!string.IsNullOrEmpty(p.RootPath) && IO.Directory.Exists(p.RootPath))
      {
        def options = (p.InitializationOptions :> JObject).ToObject.[InitializationOptions]();
        LoadSolution(p.RootPath, options)
      }

      WriteResult(id, result);
    }

    private InitializedHandler(_ : InitializedParams) : void
    {
    }

    private ShutdownHandler(_ : object, id : object) : void
    {
      WriteResult(id, null);
    }

    private ExitHandler(_ : object) : void
    {
      _router.AddMessage(ClientMessage.Shutdown());
    }

    private WorkspaceDidChangeConfigurationHandler(_ : DidChangeConfigurationParams) : void
    {
    }

    private TextDocumentDidOpenHandler(p : DidOpenTextDocumentParams) : void
    {
      def document = p.TextDocument;
      Log.Message("TextDocumentDidOpenHandler " + document.Uri, ConsoleColor.Cyan);
      def fileId   = _solution.GetFileId(document.Uri);
      def version  = FileVersion(document.Version);
      foreach (project in _solution.GetProjects(fileId))
        _router.AddMessage(ClientMessage.FileActivated(project.ProjectId, fileId, version));
      otherwise
      {
        def path = document.Uri.LocalPath;
        def isDriveLetter(c : char) : bool { c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' }
        def fixedPath = if (path.Length > 3 && path[0] == '/' && isDriveLetter(path[1]) && path[2] == ':') path.Substring(1) else path;
        def project = _solution.OpenProject(fixedPath);
        _router.AddMessage(ClientMessage.FileActivated(project.ProjectId, fileId, version));
      }
    }

    private TextDocumentDidCloseHandler(p : DidCloseTextDocumentParams) : void
    {
      def fileId = _solution.GetFileId(p.TextDocument.Uri);
      Log.Message("TextDocumentDidCloseHandler " + p.TextDocument.Uri, ConsoleColor.Cyan);
      _fileToCompilerMessageMap[fileId] = null;
      foreach (project in _solution.GetProjects(fileId))
        _router.AddMessage(ClientMessage.FileDeactivated(project.ProjectId, fileId));
    }

    private static ToStringDidChangeTextDocumentParamsToString(msg : DidChangeTextDocumentParams) : string
    {
      $<#DidChangeTextDocumentParams(
Version: $(msg.TextDocument.Version)  Uri: '$(msg.TextDocument.Uri)'
..$(msg.ContentChanges; "\r\n"; TextDocumentContentChangeEventToString)#>
    }

    private static TextDocumentContentChangeEventToString(change :  TextDocumentContentChangeEvent) : string
    {
      def r = change.Range;
      r.Start.Line + ":" + r.Start.Character + "#" + r.End.Line + ":" + r.End.Character + " «" + change.Text + "»"
    }

    private TextDocumentDidChangeHandler(p : DidChangeTextDocumentParams) : void
    {
      Log.Message($"LSP $(ToStringDidChangeTextDocumentParamsToString(p))", ConsoleColor.Cyan);

      def document = p.TextDocument;
      def changes  = p.ContentChanges;
      def fileId   = _solution.GetFileId(document.Uri);
      def version  = FileVersion(document.Version ?? -1);
      def message  =
        if (changes.Length == 1)
        {
          ClientMessage.FileChanged(fileId, version, Convert(changes[0]), VersionedPos(Convert(changes[0].Range.End), version))
        }
        else
        {
          def builder = ImmutableArray.CreateBuilder(changes.Length);
          for (mutable i = changes.Length - 1; i >= 0; i--)
            builder.Add(Convert(changes[i]));
          ClientMessage.FileChangedBatch(fileId, version, builder.MoveToImmutable(), VersionedPos.Invalid);
        }
      _router.AddMessage(message);
    }

    private TextDocumentDidSaveHandler(p : DidSaveTextDocumentParams) : void
    {
      Log.Message($"LSP TextDocumentDidSaveHandler $(p.TextDocument) «$(p.Text)»", ConsoleColor.Cyan);
    }

    private TextDocumentDocumentHighlightHandler(p : TextDocumentPositionParams, id : object) : void
    {
      def document = p.TextDocument;
      def fileId   = _solution.GetFileId(document.Uri);
      def position = VersionedPos(Convert(p.Position), FileVersion.Invalid);
      when (_solution.TryGetFirstProjects(fileId) is VSome(project))
        _router.AddMessage(ClientMessage.FindSymbolReferences(project.ProjectId, fileId, position, true, RegisterRequest(id, DocumentHighlight)));
    }

    private TextDocumentReferencesHandler(p : ReferenceParams, id : object) : void
    {
      def document = p.TextDocument;
      def fileId   = _solution.GetFileId(document.Uri);
      def position = VersionedPos(Convert(p.Position), FileVersion.Invalid);
      when (_solution.TryGetFirstProjects(fileId) is VSome(project))
        _router.AddMessage(ClientMessage.FindSymbolReferences(project.ProjectId, fileId, position, false, RegisterRequest(id, FindReferences(_, _, p.Context.IncludeDeclaration))));
    }

    private TextDocumentHoverHandler(p : TextDocumentPositionParams, id : object) : void
    {
      def document = p.TextDocument;
      def fileId   = _solution.GetFileId(document.Uri);
      def position = VersionedPos(Convert(p.Position), FileVersion.Invalid);
      when (_solution.TryGetFirstProjects(fileId) is VSome(project))
        _router.AddMessage(ClientMessage.GetHint(project.ProjectId, fileId, position, RegisterRequest(id, ShowHint(_, _, p.Position))));
    }

    private TextDocumentCompletionHandler(p : CompletionParams, id : object) : void
    {
      def document = p.TextDocument;
      def fileId   = _solution.GetFileId(document.Uri);
      def position = VersionedPos(Convert(p.Position), FileVersion.Invalid);
      def oldCompletionId = Interlocked.Exchange(ref pendingCompletionId, id);
      if (oldCompletionId != null)
        WriteError(oldCompletionId, LspErrorCode.RequestCancelled, "")
      else when (_solution.TryGetFirstProjects(fileId) is VSome(project))
        _router.AddMessage(ClientMessage.CompleteWord(project.ProjectId, fileId, position));
    }

    private TextDocumentDefinition(p : TextDocumentPositionParams, id : object) : void
    {
      def document        = p.TextDocument;
      def fileId          = _solution.GetFileId(document.Uri);
      def position        = VersionedPos(Convert(p.Position), FileVersion.Invalid);
      when (_solution.TryGetFirstProjects(fileId) is VSome(project))
        _router.AddMessage(ClientMessage.FindSymbolDefinitions(project.ProjectId, fileId, position, RegisterRequest(id, FindDefinitions(_, _))));
    }

    private WriteError(id : object, code : LspErrorCode, message : string) : void
    {
      lock (_writer)
        _writer.WriteError(id, code, message)
    }

    private WriteResult(id : object, body : object) : void
    {
      lock (_writer)
        _writer.WriteResult(id, body)
    }

    private WriteNotification[T](method : LspNotification[T], @params : T) : void
    {
      lock (_writer)
        _writer.WriteNotification(method.Name, @params)
    }

    private LoadSolution(path : string, options : InitializationOptions) : void
    {
      _solution = LspSolution(_router, SolutionId(0), options.Config, ImmutableArray.Create(options.FileExtension)); // TODO: Add support of multiple extensions
      _router.AddMessage(ClientMessage.SolutionStartLoading(_solution.SolutionId, path));
      _ = _solution.OpenProject(path); // TODO: Add support of multiproject
      _router.AddMessage(ClientMessage.SolutionLoaded(_solution.SolutionId));
    }

    private DocumentHighlight(symbols : ImmutableArray[SymbolReferences], id : object) : void
    {
      def result = List();
      foreach ((range, _) in ConvertRanges(symbols, true))
      {
        result.Add(DocumentHighlight() <-
        {
          Range = range;
          Kind = DocumentHighlightKind.Text
        });
      }
      WriteResult(id, result);
    }

    private FindReferences(symbols : ImmutableArray[SymbolReferences], id : object, includeDeclaration : bool) : void
    {
      def result = List();
      foreach ((range, fileId) in ConvertRanges(symbols, includeDeclaration))
      {
        result.Add(LSP.Location() <-
        {
          Range = range;
          Uri = _solution.GetUri(fileId)
        });
      }
      WriteResult(id, result);
    }

    private FindDefinitions(symbols : ImmutableArray[SymbolLocation], id : object) : void
    {
      def result = List();
      foreach ((range, fileId) in ConvertRanges(symbols))
      {
        result.Add(LSP.Location() <-
        {
          Range = range;
          Uri = _solution.GetUri(fileId)
        });
      }
      WriteResult(id, result);
    }

    private ShowHint(text : string, id : object, position : LSP.Position) : void
    {
      def value = HintMlToMarkdown(text);

      WriteResult(id, Hover() <-
      {
        Contents = new (kind = "markdown", value = value); // TODO: transform XML to Markdown
        Range    = LSP.Range() <- { Start = position; End = LSP.Position(position.Line, position.Character + 1) }
      });
    }

    private static HintMlToMarkdown(text : string) : string
    {
      def builder = Text.StringBuilder();
      def processNode(node : XNode) : void
      {
        | XText as t => _ = builder.Append(t.Value);
        | XElement as e when e.Name == "keyword" => _ = builder.Append("**"); _ = builder.Append(e.Value); _ = builder.Append("**");
        | XElement as e when e.Name == "symbol"  => _ = builder.Append("*"); _ = builder.Append(e.Value); _ = builder.Append("*");
        | XElement as e when e.Name == "ref"     => _ = builder.Append(e.Attribute("hint").Value);
        | XElement as e when e.Name == "br"      => _ = builder.AppendLine();
        | XElement as e => _ = builder.Append(e.Value);
        | _ => ()
      }
      def root = XElement.Parse(text, LoadOptions.PreserveWhitespace);
      foreach (n in root.Nodes())
        processNode(n);
      builder.ToString()
    }

    private CompleteWord(fileId : FileId, completionList : ImmutableArray[CompletionElem], id : object) : void
    {
      _router.AddMessage(ClientMessage.FileReparse(fileId));
      def result = List();
      foreach (x in completionList)
      {
        result.Add(LSP.CompletionItem() <-
        {
          Label = x.Text
        });
      }
      WriteResult(id, result);
    }

    private Convert(range : Messages.Range) : LSP.Range
    {
      Range() <-
      {
        Start = Position() <- { Line = range.StartLine - 1; Character = range.StartColumn - 1 };
        End   = Position() <- { Line = range.EndLine   - 1; Character = range.EndColumn   - 1 }
      }
    }

    private ConvertRanges(symbols : ImmutableArray[SymbolLocation]) : Seq[LSP.Range * FileId]
    {
      foreach (s in symbols)
      {
        def loc = s.Location;
        yield (Convert(loc.Range), loc.File.FileId);
      }
    }

    private ConvertRanges(symbols : ImmutableArray[SymbolReferences], includeDeclaration : bool) : Seq[LSP.Range * FileId]
    {
      foreach (s in symbols)
      {
        when (includeDeclaration)
        {
          foreach (d in s.Definitions)
            yield (Convert(d.Location.Range), d.Location.File.FileId);
        }

        foreach (r in s.References)
        foreach (g in r.Ranges)
          yield (Convert(g), r.File.FileId);
      }
    }

    private static Convert(c : TextDocumentContentChangeEvent) : FileChange
    {
        def newText = c.Text;
        def isEmpty = string.IsNullOrEmpty(newText);
        if (c.RangeLength == 0 && !isEmpty)
          FileChange.Insert(Convert(c.Range.Start), newText)
        else if (c.RangeLength > 0 && isEmpty)
          FileChange.Delete(Convert(c.Range))
        else
          FileChange.Replace(Convert(c.Range), newText)
    }

    private static Convert(p : Position) : UIPosition
    {
      UIPosition.LineCharacter(p.Line + 1, p.Character + 1)
    }

    private static Convert(p : LSP.Range) : UISpan
    {
      UISpan(Convert(p.Start), Convert(p.End))
    }

    private RegisterRequest[TResponse](id : object, completionHandler : Action[TResponse, object]) : uint
    {
      def tag = unchecked (Interlocked.Increment(ref _tagCounter) :> uint);
      _requestTable[tag] = (id, completionHandler);
      tag
    }

    private CompleteRequest[TResponse](tag : uint, response : TResponse) : void
    {
      mutable result;
      when (_requestTable.TryRemove(tag, out result))
      {
        def completionHandler = result[1] :> Action[TResponse, object];
        completionHandler(response, result[0])
      }
    }

    [Conditional("NitraServerChangeLog")]
    private InitChangeLog() : void
    {
      def logDir = @"c:\!Logs\";

      if (IO.Directory.Exists(logDir))
      {
        def di = IO.DirectoryInfo(logDir);
        foreach (file in di.GetFiles())
            file.Delete();
      }
      else
        _ = IO.Directory.CreateDirectory(logDir);
    }

    private class InitializationOptions
    {
      public Config : Config { get; set; }

      public FileExtension : string { get; set; }

      public References : array[string] { get; set; }
    }
  }
}
