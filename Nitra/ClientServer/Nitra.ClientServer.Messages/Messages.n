using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Macros;

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using System.Xml.Serialization;

namespace Nitra.ClientServer.Messages
{
  public module Constants
  {
    public        AsyncResponsePipeSuffix : string = "-async-response";
    public        ResponsePipeSuffix      : string = "-response";
    public        RequestPipeSuffix       : string = "-request";
    public static AssemblyVersionGuid     : string = MakeGuidString();
  }

  [NitraMessage]
  public abstract class Message { }

  [NitraMessage]
  public abstract class RouterMessage : Message { }
  
  [NitraMessage]
  public variant ClientMessage : RouterMessage
  {
    | CheckVersion             { assemblyVersionGuid : string; }
    | SolutionStartLoading     { id : int; fullPath : string; }
    | SolutionLoaded           { id : int; }
    | SolutionUnloaded         { id : int; }
    | ProjectStartLoading      { id : int; fullPath : string; config : Config; }
    | ProjectLoaded            { id : int; }
    | ProjectUnloaded          { id : int; }
    | ProjectRename            { oldId : int; newId : int; newPath : string; }
    | ProjectReferenceLoaded   { projectId : int; referencedProjectId : int; }
    | ProjectReferenceUnloaded { projectId : int; referencedProjectId : int; }
    | ReferenceLoaded          { projectId : int; name : string; }
    | ReferenceUnloaded        { projectId : int; name : string; }
    | FileLoaded               { projectId : int; fullPath : string; id : int; version : int; }
    | FileReparse              { id : int; }
    | FileUnloaded             { id : int; }
    | FileRenamed              { oldId : int; newId : int; newPath : string; }
    | FileInMemoryLoaded       { projectId : int; id : int; name : string; content : string; }
    | FileActivated            { id : int; }
    | FileDeactivated          { id : int; }
    | FileChanged              { id : int; version : int; change : FileChange; }
    | FileChangedBatch         { id : int; version : int; changes : ImmutableArray[FileChange]; }
    | PrettyPrint              { state : PrettyPrintState; }
    | CompleteWord             { id : int; version : int; pos : int; }
    | FindSymbolReferences     { fileId : int; fileVersion : int; pos : int; }
    | FindSymbolDefinitions    { fileId : int; fileVersion : int; pos : int; }
    | ParseTreeReflection      { enable : bool; }
    | GetObjectContent         { solutionId : int; fileId : int; fileVersion : int; objectId : int; }
    | AttachDebugger           { }
    | GetLibsMetadata          { libs : ImmutableArray[string]; }
    | GetLibsSyntaxModules     { libs : ImmutableArray[string]; }
    | GetLibsProjectSupports   { libs : ImmutableArray[string]; }
    | GetFileExtensions        { projectId : int; languageNames : ImmutableArray[string]; }
    | Shutdown                 { }
    
    public override ToString() : string
    {
      match (this)
      {
        | CheckVersion             (assemblyVersionGuid)           => $<#CheckVersion            ($assemblyVersionGuid)#>
        | SolutionStartLoading     (id, fullPath)                  => $<#SolutionStartLoading    ($id, $fullPath)#>
        | SolutionLoaded           (id)                            => $<#SolutionLoaded          ($id)#>
        | SolutionUnloaded         (id)                            => $<#SolutionUnloaded        ($id)#>
        | ProjectStartLoading      (id, fullPath, languages)       => $<#ProjectStartLoading     ($id, $fullPath, $languages)#>
        | ProjectLoaded            (id)                            => $<#ProjectLoaded           ($id)#>
        | ProjectUnloaded          (id)                            => $<#ProjectUnloaded         ($id)#>
        | ProjectRename            (oldId, newId, newPath)         => $<#ProjectRename           ($oldId, $newId, $newPath)#>
        | ProjectReferenceLoaded   (projectId, refProjectId)       => $<#ProjectReferenceLoaded  ($projectId, $refProjectId)#>
        | ProjectReferenceUnloaded (projectId, refProjectId)       => $<#ProjectReferenceUnloaded($projectId, $refProjectId)#>
        | ReferenceLoaded          (projectId, fullPath)           => $<#ReferenceLoaded         ($projectId, $fullPath)#>
        | ReferenceUnloaded        (projectId, fullPath)           => $<#ReferenceUnloaded       ($projectId, $fullPath)#>
        | FileLoaded               (projectId, fullPath, id, ver)  => $<#FileLoaded              ($projectId, $fullPath, $id, $ver)#>
        | FileReparse              (id)                            => $<#FileReparse             ($id)#>
        | FileUnloaded             (id)                            => $<#FileUnloaded            ($id)#>
        | FileRenamed              (oldId, newId, newPath)         => $<#FileRenamed             ($oldId, $newId, $newPath)#>
        | FileInMemoryLoaded       (projectId, id, name, content)  => $<#FileInMemoryLoaded      ($projectId, $id, $name, $content)#>
        | FileActivated            (id)                            => $<#FileActivated           ($id)#>
        | FileDeactivated          (id)                            => $<#FileDeactivated         ($id)#>
        | FileChanged              (id, version, change)           => $<#FileChanged             ($id, $version, $change)#>
        | FileChangedBatch         (id, version, changes)          => $<#FileChangedBatch        ($id, $version, $changes)#>
        | PrettyPrint              (state)                         => $<#PrettyPrint             ($state)#>
        | CompleteWord             (id, version, pos)              => $<#CompleteWord            ($id, $version, $pos)#>
        | FindSymbolReferences     (fileId, fileVersion, pos)      => $<#FindSymbolReferences    ($fileId, $fileVersion, $pos)#>
        | FindSymbolDefinitions    (fileId, fileVersion, pos)      => $<#FindSymbolDefinitions   ($fileId, $fileVersion, $pos)#>
        | ParseTreeReflection      (enable)                        => $<#ParseTreeReflection     (enable=$enable)#>
        | GetObjectContent         (solutionId, id, v, objectId)   => $<#GetObjectContent        (solutionId=$solutionId, FileId=$id, Version=$v, ObjectId=$objectId)#>
        | AttachDebugger                                           =>  <#AttachDebugger          ()#>
        | GetLibsMetadata          (libs)                          => $<# GetLanguageInfos(..$libs) #> 
        | GetLibsSyntaxModules     (libs)                          => $<# GetLibsSyntaxModules(..$libs) #> 
        | GetLibsProjectSupports   (libs)                          => $<# GetLibsProjectSupports(..$libs) #> 
        | GetFileExtensions        (projectId, languageNames)      => $<# GetFileExtensions($projectId, ..$languageNames) #> 
        | Shutdown                                                 =>  <#Shutdown                ()#>
      }
    }
  }

  [NitraMessage]
  public variant ServerMessage
  {
    | CompleteWord          { solutionId : int; replacementSpan : NSpan; completionList : ImmutableArray[CompletionElem]; }
    | FindSymbolDefinitions { solutionId : int; referenceSpan   : NSpan; definitions    : ImmutableArray[SymbolLocation]; }
    | FindSymbolReferences  { solutionId : int; referenceSpan   : NSpan; symbols        : ImmutableArray[SymbolRreferences]; }
    | ParseTreeReflection   { solutionId : int; root : ImmutableArray[ParseTreeReflectionStruct]; }
    | ObjectContent         { solutionId : int; content : ContentDescriptor; }
    | LibsMetadata          { solutionId : int; metadatas : ImmutableArray[LibMetadata]; }
    | LibsSyntaxModules     { solutionId : int; modules   : ImmutableArray[SyntaxModules]; }
    | LibsProjectSupports   { solutionId : int; libs      : ImmutableArray[ProjectSupports]; }
    | FileExtensions        { solutionId : int; fileExtensions : ImmutableArray[string]; }

    public override ToString() : string
    {
      $<#$(this.GetType().Name)()#>
    }
  }

  [NitraMessage]
  public class ProjectSupports
  {
    public ProjectSupports : ImmutableArray[ProjectSupport];
    
    public override ToString() : string { ProjectSupports.ToString(", ") }
  }

  [NitraMessage]
  public class SyntaxModules
  {
    public Modules : ImmutableArray[string];
  }

  [NitraMessage]
  public class LibMetadata
  {
    public ProjectSupprts : ImmutableArray[string];
    public Languages      : ImmutableArray[LanguageInfo];
  }
  
  [NitraMessage, StructuralEquality]
  public struct SymbolRreferences
  {
    public SymbolId    : int;
    public Definitions : ImmutableArray[SymbolLocation];
    public References  : ImmutableArray[FileEntries]
  }
  
  
  public enum PrettyPrintState
  {
    | Disabled
    | Text
    | Html
  }
  
  [NitraMessage, StructuralEquality]
  public struct NSpan : IComparable[NSpan]
  {
    public StartPos : int;
    public EndPos   : int;
    public Length   : int { get { EndPos - StartPos }}
    
    public IsEmpty : bool
    {
      get { StartPos == EndPos }
    }
    
    public IntersectsWith(pos : int)              : bool { pos <= EndPos && pos >= StartPos }
    public IntersectsWith(start : int, end : int) : bool { start <= EndPos && end >= StartPos }
    public IntersectsWith(other : NSpan)          : bool { IntersectsWith(other.StartPos, other.EndPos) }
    public IntersectsWith(other : Location)       : bool { IntersectsWith(other.Span) }
    
    public override ToString() : string { StartPos + ", " + EndPos }
    
    public CompareTo(other : NSpan) : int
    {
      def result = StartPos.CompareTo(other.StartPos);
      if (result == 0)
        EndPos.CompareTo(other.EndPos)
      else
        result
    }
  }
  
  [NitraMessage, StructuralEquality]
  public struct SpanInfo
  {
    public Span        : NSpan;
    public SpanClassId : int;
  }
  
  [NitraMessage]
  public variant FileChange
  {
    | Insert  { pos: int; text: string }
    | Delete  { span: NSpan }
    | Replace { span: NSpan; text: string }
  }
  
  [NitraMessage, StructuralEquality]
  public struct FileIdentity : IComparable[FileIdentity]
  {
    public FileId      : int;
    public FileVersion : int;
    
    public CompareTo(other : FileIdentity) : int
    {
      FileId.CompareTo(other.FileId)
    }
  }

  [NitraMessage]
  public struct FileEntries
  {
    public File  : FileIdentity;
    public Spans : ImmutableArray[NSpan];
  }
  
  [NitraMessage]
  public struct SymbolLocation
  {
    public SymbolId : int;
    public Location : Location;
  }
  
  [NitraMessage, StructuralEquality]
  public struct Location : IComparable[Location]
  {
    public File : FileIdentity;
    public Span : NSpan;
    
    public CompareTo(other : Location) : int
    {
      mutable result = File.CompareTo(other.File);
      if (result == 0)
        Span.CompareTo(other.Span)
      else
        result
    }
  }

  public enum CompilerMessageSource : byte
  {
    | ProjectLoading
    | Parsing
    | Mapping
    | SemanticAnalysis
  }

  public enum CompilerMessageType
  {
    | FatalError = 0
    | Error      = 1
    | Warning    = 2
    | Hint       = 3
  }

  [NitraMessage]
  public struct CompilerMessage : IComparable[CompilerMessage]
  {
    public Type           : CompilerMessageType;
    public Location       : Location;
    public Text           : string;
    public Number         : int;
    public Source         : CompilerMessageSource;
    public NestedMessages : list[CompilerMessage];
    
    public CompareTo(other : CompilerMessage) : int
    {
      this.Location.CompareTo(other.Location)
    }
  }

  [NitraMessage]
  public sealed class ProjectSupport
  {
    public this()
    {
      Caption      = "";
      TypeFullName = "";
      Path         = "";
    }
    
    /// Caption from ProjectSupportAttributr of the type which implement IProjectSupport
    [XmlAttribute] public mutable Caption      : string;
    /// Fully qualified name of the type which implement IProjectSupport
    [XmlAttribute] public mutable TypeFullName : string;
    /// Path of assembly where defined the type which implement IProjectSupport
    [XmlAttribute] public mutable Path         : string;
    
    public IsNotSpecified : bool { get { string.IsNullOrEmpty(TypeFullName) || string.IsNullOrEmpty(Caption) } }
    
    public override ToString() : string { if (IsNotSpecified) "<not specified>" else Caption }
  }
  

  [NitraMessage]
  public sealed class Config
  {
    public this() { }
    
    public static InitNew() : Config
    {
      def x = Config();
      x.ProjectSupport = ProjectSupport();
      x.Languages = array(0);
      x.Libs      = array(0);
      x
    }
    
    /// Descriptions of class which implements IProjectSupport
                   public mutable ProjectSupport      : ProjectSupport;
    /// Language descriptions
    [XmlArray(ElementName="Languages", IsNullable=false)]
    [XmlArrayItem("Language")]
                   public mutable Languages           : array[LanguageInfo];
    /// Library references
    [XmlArray(ElementName="Libs", IsNullable=false)]
    [XmlArrayItem("Lib")]
                   public mutable Libs                : array[string];
  }

  [NitraMessage]
  public struct DynamicExtensionInfo
  {
    /// Fully qualified name of syntax modules which contains lanuage extensions
    [XmlAttribute] public mutable Name : string;
    /// Path of assembly where defined lanuage extensions
    [XmlAttribute] public mutable Path : string;
    
    public override ToString() : string { "DynamicExtension: " + Name }
  }
  
  [NitraMessage]
  public struct LanguageInfo
  {
    /// Fully qualified name of the lanuage
    [XmlAttribute] public mutable Name : string;
    /// Path of assembly where defined the type where defined lanuage
    [XmlAttribute] public mutable Path : string;
    /// List of dynamically loaded extensions of the lanuage
    [XmlArray(ElementName="DynamicExtensions", IsNullable=false)]
    [XmlArrayItem("Extension")]
                   public mutable DynamicExtensions : array[DynamicExtensionInfo];
    
    public override ToString() : string { "Language: " + Name }
  }
  
  [NitraMessage]
  public struct SpanClassInfo
  {
    public FullName        : string;
    public Id              : int;
    public ForegroundColor : int;

    public override ToString() : string
    {
      "SpanClass=" + FullName + " Id=" + Id
    }
  }
  
  [NitraMessage]
  public struct OutliningInfo
  {
    public Span               : NSpan;
    public IsDefaultCollapsed : bool;// TODO: use bit field
    public IsImplementation   : bool;

    public override ToString() : string
    {
      "Outlining({" + Span + (if (IsDefaultCollapsed) "}, Collapsed)" else "})")
    }
  }
  
  [NitraMessage]
  public variant CompletionElem
  {
    | Literal { text : string; }
    | Symbol  { Id : int; name : string; content : string; description : string; iconId : int; }
  }
  
  [NitraMessage]
  public variant AsyncServerMessage
  {
    public FileId      : int;
    public Version     : int;
    public SolutionlId : int;
    
    | LanguageLoaded              { spanClassInfos : ImmutableArray[SpanClassInfo]; }
    | OutliningCreated            { outlining      : ImmutableArray[OutliningInfo]; }
    | KeywordsHighlightingCreated { spanInfos      : ImmutableArray[SpanInfo]; }
    | SymbolsHighlightingCreated  { spanInfos      : ImmutableArray[SpanInfo]; }
    | ProjectLoadingMessages      { messages       : array[CompilerMessage]; }
    | ParsingMessages             { messages       : array[CompilerMessage]; }
    | MappingMessages             { messages       : array[CompilerMessage]; }
    | SemanticAnalysisMessages    { messages       : array[CompilerMessage]; }
    | SemanticAnalysisDone
    | PrettyPrintCreated          { type : PrettyPrintState; text : string; }
    | ReflectionStructCreated     { root : ParseTreeReflectionStruct; }
    | RefreshReferencesFailed     { exception : string; }
    | RefreshProjectFailed        { exception : string; }
    | Exception                   { exception : string; }
    
    public override ToString() : string 
    {
      $<#$(this.GetType().Name)($FileId)#>
    }
  }
  
  public enum ReflectionKind
  {
    | Normal
    | Recovered
    | Ambiguous
    | Deleted
  }
  
  [NitraMessage]
  public class ReflectionInfo
  {
    public ShortName           : string;
    public FullName            : string;
    public IsMarker            : bool;
    public CanParseEmptyString : bool;
  }

  [NitraMessage]
  public class ParseTreeReflectionStruct
  {
    public info        : ReflectionInfo;
    public description : string;
    public kind        : ReflectionKind;
    public span        : NSpan;
    public children    : ImmutableArray[ParseTreeReflectionStruct];

    public Info        : ReflectionInfo                   { get { info        } }
    public Description : string                           { get { description } }
    public Kind        : ReflectionKind                   { get { kind        } }
    public Span        : NSpan                            { get { span        } }
    public Children    : ImmutableArray[ParseTreeReflectionStruct] { get { children    } }
    
    public override ToString() : string{ Description + " Count=" + Children.Length  }
  }
  
  [NitraMessage]
  public class GrammarDescriptor
  {
    public FullName: string;
    public AssemblyLocation: string;
  }
  
  [NitraMessage]
  public class LibReference
  {
    public Name: string;
  }
  
  public enum PropertyKind
  {
    | Simple
    | DependentIn
    | DependentOut
    | DependentInOut
    | Ast
  }

  [NitraMessage]
  public variant ContentDescriptor
  {
    | Fail      { msg : string; }
    | Members   { members : array[PropertyDescriptor]; }
    | Items     { items   : array[ObjectDescriptor]; }
    | AstItems  { members : array[PropertyDescriptor]; items   : array[ObjectDescriptor]; }
  }

  [NitraMessage]
  public variant ObjectDescriptor
  {
    | Unknown       { str : string; }
    | Null          { }
    | NotEvaluated  { }
    | Ast           { span : NSpan; id : int; str : string;                      typeName : string; typeFullName : string; mutable members : array[PropertyDescriptor]; }
    | Symbol        {               id : int; name : string;  fullName : string; typeName : string; typeFullName : string; mutable members : array[PropertyDescriptor]; }
    | Object        {               id : int; str : string;                      typeName : string; typeFullName : string; mutable members : array[PropertyDescriptor]; }
    | AstList       { span : NSpan; id : int; mutable items   : array[ObjectDescriptor]; mutable members : array[PropertyDescriptor]; count : int; }
    | Seq           {               id : int; mutable items   : array[ObjectDescriptor]; count : int; }
    | String        { value : string; }
    | Int16         { value : System.Int16  ; }
    | Int32         { value : System.Int32  ; }
    | Int64         { value : System.Int64  ; }
    | Char          { value : System.Char   ; }
    | SByte         { value : System.SByte  ; }
    | UInt16        { value : System.UInt16 ; }
    | UInt32        { value : System.UInt32 ; }
    | UInt64        { value : System.UInt64 ; }
    | Byte          { value : System.Byte   ; }
    | Single        { value : System.Single ; }
    | Double        { value : System.Double ; }
    | Boolean       { value : System.Boolean; }
    | Parsed        { span : NSpan; value : ObjectDescriptor; }
    
    public IsObject   : bool { get { match (this) { | Ast | Symbol | Object => true | _ => false } } }
    public IsSeq      : bool { get { match (this) { | AstList | Seq => true | _ => false } } }
    public Properties : array[PropertyDescriptor]
    {
      get
      {
        match (this)
        {
          | Ast     as x => x.members
          | Symbol  as x => x.members
          | Object  as x => x.members
          | AstList as x => x.members
          | _      => null
        }
      }
    }
    public Items : array[ObjectDescriptor]
    {
      get
      {
        match (this)
        {
          | AstList as x => x.items
          | Seq     as x => x.items
          | _      => null
        }
      }
    }
    public Count : int
    {
      get
      {
        match (this)
        {
          | AstList as x => x.count
          | Seq     as x => x.count
          | _            => 0
        }
      }
    }
    public Id : int
    {
      get
      {
        match (this)
        {
          | Ast           as x => x.id
          | Symbol        as x => x.id
          | Object        as x => x.id
          | AstList       as x => x.id
          | Seq           as x => x.id         
          | _                  => -1
        }
      }
    }
    public Span : NSpan
    {
      get
      {
        match (this)
        {
          | Ast           as x => x.span
          | AstList       as x => x.span
          | Parsed        as x => x.span
          | _                  => NSpan()
        }
      }
    }
    public Value : object
    {
      get
      {
        match (this)
        {
          | Parsed        as x => "ParserValue(" + x.value + ")"
          | Ast           as x when x.Id == 0 => "<Root>"
          | Ast           as x => x.typeName + " \"" + x.str + "\""
          | Symbol        as x => x.name
          | Object        as x => x.str
          | AstList       as x => "Count=" + x.Count
          | Seq           as x => "Count=" + x.Count
          | String        as x => "\"" + x.value + "\""
          | Int16         as x => x.value.ToString()
          | Int32         as x => x.value.ToString()
          | Int64         as x => x.value.ToString()
          | Char          as x => x.value.ToString()
          | SByte         as x => x.value.ToString()
          | UInt16        as x => x.value.ToString()
          | UInt32        as x => x.value.ToString()
          | UInt64        as x => x.value.ToString()
          | Byte          as x => x.value.ToString()
          | Single        as x => x.value.ToString()
          | Double        as x => x.value.ToString()
          | Boolean       as x => x.value.ToString()
          | Unknown       as x => "Unknown<" + x.str + ">"
          | Null         => "<null>"
          | NotEvaluated => "<not evaluated>"
          | _            => null
        }
      }
    }
    public SetContent(content : ContentDescriptor) : void
    {
      | Members(members) =>
        match (this)
        {
          | Ast    as x => x.members = members;
          | Symbol as x => x.members = members;
          | Object as x => x.members = members;
          | _           => assert(false);
        }

      | Items(items)     =>
        match (this)
        {
          | AstList as x => x.items = items;
          | Seq     as x => x.items = items;
          | _            => assert(false);
        }
        
      | AstItems(members, items) =>
        match (this)
        {
          | AstList as x => x.members = members; x.items = items;
          | _            => assert(false);
        }

      | Fail => ()
   }
    public override ToString() : string
    {
      match (Value)
      {
        | null => "<null>"
        | x => x.ToString()
      }
    }
 }

  [NitraMessage]
  public class PropertyDescriptor
  {
    public Kind   : PropertyKind;
    public Name   : string;
    public Object : ObjectDescriptor;

    public override ToString() : string
    {
      def prefix =
        match (Kind)
        {
          | PropertyKind.DependentIn    => "in "
          | PropertyKind.DependentOut   => "out "
          | PropertyKind.DependentInOut => "inout "
          | PropertyKind.Ast            => "ast "
          | PropertyKind.Simple         => null
        };

      prefix + Name + " " + Object
    }
  }
}