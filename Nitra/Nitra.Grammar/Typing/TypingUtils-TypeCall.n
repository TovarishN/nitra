using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Runtime;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;

using G = NitraSyntaxParseTree;
using L = NitraLiteralsParseTree;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal TypeCall(
      baseRule      : option[ExtensibleRuleSymbol],
      _precedence   : PrecedenceInfo,
      _fieldName    : option[string],
      context       : Context,
      options       : RuleDefinitionOptions,
      QualifiedName : G.QualifiedIdentifier,
      RuleAruments  : Nitra.OptionParseTree[G.RuleExpression.Call.Nested.RuleAruments],
      BindingPower  : OptionParseTree[SequenceParseTree[NSpan, Nitra.OptionParseTree[NSpan], G.PrecedenceName]]
    ) : Rule
    {
      def newFieldName : string = _fieldName ?? QualifiedName.LastIdentifier().Value;

      when (context.TryBind.[RuleAliasSymbol](QualifiedName) is SymbolRef.Some(alias))
        return alias.Rule.Typing(baseRule, _precedence, Some(newFieldName), context, options);

      def ruleRef = context.Bind.[RuleSymbol](QualifiedName);
      def (type, spanClass) =
        match (ruleRef)
        {
          | SymbolRef.Some(RuleParameterSymbol as parameterSymbol) => 
            match (parameterSymbol.Kind)
            {
              | Regex  => (RuleType.Chars(None()), null)
              | Syntax
              | Token  => (RuleType.RuleParameter(parameterSymbol), null)
            }
            
          | SymbolRef.Some(RuleDefSymbol as ruleSymbol) => 
            when (ruleSymbol is ExtensionRuleSymbol)
              context.Error(QualifiedName,
                "You can't use directly reference an extension rule. Use reference to extensible rule instead or make a separate rule.");

            def declarationSiteContext = context.GetContext.[RuleDeclarationSiteContext]();
            match (declarationSiteContext.DeclarationSite)
            {
              | declarationSite is ExtendSyntaxSymbol =>
                when (declarationSite.Extend is Some(declaration) when declaration.IsToken)
                  context.Error(ruleRef, "Can't refer to a syntax rule from token.");

              | declarationSite is RuleDefSymbol =>
                when (declarationSite.IsToken && !ruleSymbol.IsToken)
                  context.Error(ruleRef, "Can't refer to a syntax rule from token.");
              // TODO: проверить IsToken у параметра правила

              | _                  => ()
            }

            (ruleSymbol.Type, ruleSymbol.Options.SpanClassSymbol)
          | _ => (RuleType.Void(), null)
        };

      def bp =
        if (BindingPower.HasValue)
        {
          def value = BindingPower.Value;
          def isStrong = value.Item2.HasValue;
          value.Item3.GetBindingPowerInfo(_precedence.Context, isStrong);
        }
        else
        {
          match (baseRule, ruleRef)
          {
            | (Some(baseRuleSymbol), SymbolRef.Some(ruleRefSymbol)) when baseRuleSymbol == ruleRefSymbol =>
              BindingPowerInfo(_precedence.Context.GetPrecedence(), _precedence.IsStrong)
            | _ => BindingPowerInfo(PrecedenceReference.Zero(), _precedence.IsStrong)
          }
        }
      def arguments = if (RuleAruments.HasValue)
      {
        def arguments = RuleAruments.Value.RuleAruments.Item1;
        def res = LightList();
        foreach (argument in arguments)
        {
          match (argument)
          {
            | G.RuleExpression.Call.Nested.RuleAruments.Nested.RuleArument.Reference as reference =>
              def ruleRef = context.Bind.[RuleSymbol](reference.Reference);
              res.Add(ruleRef)

            //| G.RuleExpression.Call.Nested.RuleAruments.Nested.RuleArument.RegexExpression =>
            //  assert3(false, "Not implemented.");//TODO: 

            | _ => assert(false);
          }
        }
        res.ToNList();
      }
      else [];

      Rule.Call(QualifiedName.Location, type, newFieldName, ruleRef, arguments, bp, spanClass);
    }
  }
}
