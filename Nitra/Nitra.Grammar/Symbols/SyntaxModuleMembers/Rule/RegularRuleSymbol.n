using Nitra.Model;
using Nitra.Typing.RuleMethod;

using Nemerle;
using System;

using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  [Record, ExportableSymbol]
  public abstract class RegularRuleSymbol : RuleDefSymbol, IRuleDeclarationSite
  {
    public sealed override Type                : RuleType    { get { RuleType.Chars(None()) } }
    public sealed override IsToken             : bool        { get { true } }
    public        abstract Rule                : RegularRule { get; }
    public                 CanParseEmptyString : option[bool] { [Memoize] get { Fsm.Map(fsm => fsm.OkStates.Contains(fsm.StartState)) } }
    public                 FirstCharLowerBound : option[char] {           get { Fsm.Map(_ => FirstCharBounds[0]) } }
    public                 FirstCharUpperBound : option[char] {           get { Fsm.Map(_ => FirstCharBounds[1]) } }
    public                 Fsm                 : option[FSM]
    {
      [Memoize] get
      {
        assert(Node != null);
        this.Rule.ConvertRegularRuleToFsm(Node.Project).Map(FSMTransform.MakeDeterministic)
      }
    }
    public        override Description         : string      { get { "regular rule" } }

    private FirstCharBounds : char * char
    {
      [Memoize] get
      {
        mutable totalRange = RangeSet();
        foreach (Symbol(Chars = range, From = from) when from == Fsm.Value.StartState in Fsm.Value.Transitions)
          totalRange = totalRange.Sum(range);
        match (totalRange.GetBounds())
        {
          | None => (char.MinValue, char.MaxValue)
          | Some(bounds) => bounds
        }
      }
    }
  }

  public sealed class ParsedRegularRuleSymbol : RegularRuleSymbol
  {
    public this(node : G.RegexRule, declarationSite : IRuleDeclarationSite, parameters : list[RuleParameterSymbol])
    {
      base(node.Name);
      _node = node;
      DeclarationSite = declarationSite;
      Parameters      = parameters;
    }

    private _node                        : G.RegexRule;

    public override DeclarationSite     : IRuleDeclarationSite      { get; }
    public override Options             : RuleDefinitionOptions     { [Memoize] get { _node.RuleAttributes.Options(DeclarationSite.GetDefaultRuleDefinitionOptions()) } }
    public override Rule                : RegularRule               {           get { _node.Regex() } }
    public override LastLocation        : option[Location]          { [Memoize] get { Some(_node.RuleBody.GetLastLocation()) } }
    public override IdInGrammar         : int                       { [Memoize] get { DeclaringModule.GetNewRuleId() } }
    public override Parameters          : list[RuleParameterSymbol] {           get; }
  }
}
