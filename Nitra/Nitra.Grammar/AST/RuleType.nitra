using DotNet;

using Nitra;
using Nitra.Declarations;

using System.Collections.Generic;

namespace Nitra.Ast
{
  abstract declaration RuleType : Type
  {
    symbol
    {
      Kind = "rule type";
    }
  }

  abstract declaration RuleVoidType : RuleType { }

  declaration RuleVoidTypeImpl : RuleVoidType
  {
    symbol
    {
      ToString = "void";
    }
  }
  declaration RuleListType    : RuleType
  {
    symbol
    {
      in ElemType  : RuleTypeSymbol;
      Scope    = ListRuleTypeScope(this, context);
      ToString = ElemType + "*";

      DecomposeType =
        if (IsElemTypeEvaluated)
          VSome(TypeStructure(WellKnownSymbols.ListRuleType, ElemType))
        else
          VNone();
    }
  }
  declaration RuleTupleType   : RuleType
  {
    symbol
    {
      in ElemTypes : IList[RuleTypeSymbol];
      Scope    = TupleRuleTypeScope(this, context);
      ToString = "(" + string.Join(", ", ElemTypes) + ")";

      DecomposeType =
        if (IsElemTypesEvaluated)
          VSome(TypeStructure(WellKnownSymbols.TupleRuleType, ElemTypes))
        else
          VNone();
    }
  }
  declaration RuleOptionType  : RuleType
  {
    symbol
    {
      in ValueType : RuleTypeSymbol;
      Scope    = OptionRuleTypeScope(this, context);
      ToString = ValueType + "?";

      DecomposeType =
        if (IsValueTypeEvaluated)
          VSome(TypeStructure(WellKnownSymbols.OptionRuleType, ValueType))
        else
          VNone();
    }
  }
  abstract declaration RuleCharsType : RuleType { }
  declaration RuleLiteralType : RuleCharsType
  {
    symbol { ToString = "chars"; }
  }
}
