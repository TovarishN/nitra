using Nitra;
using Nitra.Utils;
using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Runtime;
using Nitra.Typing;
using Nitra.Typing.TypingUtils;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

syntax module NitraSyntax
{
  using Outline;
  using PrettyPrint;
  using TokenNames;
  using StandardSpanClasses;
  using Whitespaces;
  using Identifiers;
  using CStyleComments;
  using NitraLiterals;

  span class InlineComment;
  span class MultilineComment;

  literal Pipe = "|";

  keyword regex IdentifierStartCharacter (IdentifierPartCharacters | '-')* rule S;

  alias Name            = Identifier;
  alias Reference       = Identifier;
  alias QualifiedName   = QualifiedIdentifier;

  regex PredefinedType = "void" | "int" | "string";

  regex Keyword = "as" | "syntax" | "declaration" | "declarations" | "ast" | "asts" | "extend" | "module"
                | "marker" | "map" | "token" | "field" | "span" | "alias" | "regex" | "literal" | "decompose"
                | "multiple" | "optional" | "abstract" | "in" | "out" | "inout" | "class"
                | "rule" | "precedence" | "using" | "namespace" | PredefinedType | "right-associative";

  extend token IgnoreToken
  {
    | [SpanClass(InlineComment)]   SingleLineComment
    | [SpanClass(MultilineComment)] MultiLineComment
  }

  token Identifier                       = !(Keyword !IdentifierPartCharacters) IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : Nitra.Model.Identifier = Nitra.Model.Identifier(this, IdentifierBody);
  }

  [ExplicitSpaces]
  syntax QualifiedIdentifier              = Names=(Identifier; s "." s)+
  {
    Identifiers() : list[Nitra.Model.Identifier] = Names.Item1.Identifiers();
    Parts() : list[string] = Names.Item1.MapToList(_.Value());
    CalcLocations() : list[Nitra.Location] = Names.Item1.MapToList(_.Location);
    LastIdentifier() : Nitra.Model.Identifier = Names.Item1[Names.Item1.Count - 1].Identifier();
  }

  ///////////////////////////////////////////////////////////////////////////
  //

  [StartRule]
  syntax Start = NamespaceBody
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = NamespaceBody.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context = NamespaceBody.MakeContext(parent);
    TypeSyntaxMappings() : void = NamespaceBody.TypeSyntaxMappings();
    TypeAst() : void = NamespaceBody.TypeAst();
    Typing() : void = NamespaceBody.Typing();
    TypeSymbolMembers() : void = NamespaceBody.TypeSymbolMembers();
  }

  syntax Usings = outline_hiden outline_begin Using* outline_end_before
  {
    MakeContext(parent : Context) : Context = FoldThrough(Usings, parent, _.MakeContext(_));
  }

  syntax NamespaceBody = Usings NamespaceMember*
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = foreach (topDecl in NamespaceMembers) topDecl.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context
    {
      def context1 = Usings.MakeContext(parent);
      def context2 = PassThrough(NamespaceMembers, context1, _.MakeContext(_));
      context2
    }
    TypeSyntaxMappings() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSyntaxMappings();
    TypeAst() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeAst();
    Typing() : void = foreach (topDecl in NamespaceMembers) topDecl.Typing();
    TypeSymbolMembers() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSymbolMembers();
  }

  syntax Using
  {
    [Cached] MakeContext(parent : Context) : Context;

    | UsingOpen  = "using" sm NamespaceOrType=QualifiedName ";" nl
      {
        override MakeContext = OpenNamespaceOrTypeContext(parent, NamespaceOrType);
      }
    | UsingAlias = "using" Name sm "=" sm NamespaceOrType=QualifiedName ";" nl
      {
        override MakeContext = NamespaceOrTypeAliasContext(parent, Name, NamespaceOrType);
      }
  }

  syntax NitraTypeArguments
  {
    Typing(context : Context) : list[NType];
    | Corners = "<" (NitraType; "," sm; ?)+ ">" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
    | Braces  = "[" (NitraType; "," sm; ?)+ "]" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
  }

  syntax NitraTypeName = Identifier NitraTypeArguments?
  {
    Typing(context : Context) : TypeNamePart
    {
      def name = this.Identifier.GetText();
      def env  = context.GetNemerleEnvironment();
      if (this.NitraTypeArgumentsOpt.HasValue)
        TypeNamePart(this.Identifier.Location + this.NitraTypeArgumentsOpt.Location, name, this.NitraTypeArgumentsOpt.Value.Typing(context), env)
      else
        TypeNamePart(this.Identifier.Location, name, [], env)
    }
  }

  syntax NitraType
  {
    Typing(context : Context) : NType * bool;

    | PredefinedType
      {
        override Typing
        {
          _ = context;
          def value = match (GetText(this.PredefinedType))
          {
            | "void"   => NPredefinedType.Void
            | "int"    => NPredefinedType.Int
            | "string" => NPredefinedType.String
            | _        => assert3(false)
          };
          (NType.Predefined(this.Location, value), false);
        }
      }
    | QualifiedType  = (NitraTypeName; ".")+
      {
        override Typing
        {
          def parts = LightList();
          foreach (t in this.NitraTypeNames.Item1)
            parts.Add(t.Typing(context));
          (NType.Qualified(this.Location, parts.ToNList()), false);
        }
      }
    | Braces         = "(" NitraType ")"
      {
        override Typing = (this.NitraType.Typing(context)[0], false);
      }

    precedence Function:
    | Func           = NitraType "->" NitraType    right-associative
      {
        override Typing = (NType.Func(this.Location, this.NitraType1.Typing(context)[0], this.NitraType2.Typing(context)[0]), false);
      }

    precedence Tuple:
    | Tuple          = NitraType "*" NitraType     right-associative
      {
        override Typing
        {
          def first = this.NitraType1.Typing(context)[0];
          match (this.NitraType2.Typing(context))
          {
            | (NType.Tuple(members), true) => (NType.Tuple(this.Location, first :: members), true)
            | (second, _)                  => (NType.Tuple(this.Location, [first, second]), true)
          }
        }
      }

    precedence RepeatModifier:
    | OptionList     = NitraType "*"
      {
        override Typing = (NType.OptionList(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | List           = NitraType "+"
      {
        override Typing = (NType.List(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | Option         = NitraType "?"
      {
        override Typing = (NType.Option(this.Location, this.NitraType.Typing(context)[0]), false);
      }
  }

  syntax AstInheritance = ":" sm BaseAsts=(QualifiedIdentifier; "," sm)+
  {
    Typing(context : Context, isDeclaration : bool) : list[AstSymbol] = TypingUtils.BindAstInheritanceList(this.BaseAsts.Item1, context, isDeclaration);
  }

  syntax DependentProperty = Modifier Name sm ":" sm NitraType PropertyValue
  {
    token Modifier
    {
      Type() : DependentPropertyDirection * bool;
      | "in"    { override Type = (DependentPropertyDirection.In,  false); }
      | "out"   { override Type = (DependentPropertyDirection.Out, false); }
      | "inout" { override Type = (DependentPropertyDirection.In,  true ); }
    }

    syntax PropertyValue
    {
      ValueLocation() : Nitra.Location;
      HasValue() : bool;

      | Expression = sm "=" sm Expression ";" nl
        {
          override ValueLocation = Expression.Location;
          override HasValue = true;
        }
      | Empty = ";" nl
        {
          override ValueLocation = this.Location.FromStart();
          override HasValue = false;
        }
    }

    [Cached] Stage() : int = this.Context.TryGetContext.[AstDependentPropertyStageContext]()?.Stage;
    [Cached] MakeSymbol1(propertyContainer : PropertyContainerSymbol, direction : DependentPropertyDirection, isInOut : bool) : ParsedDependentPropertySymbol = ParsedDependentPropertySymbol(this, propertyContainer, direction, isInOut);
    [Cached] MakeSymbol2(propertyContainer : PropertyContainerSymbol) : ParsedDependentPropertySymbol = ParsedDependentPropertySymbol(this, propertyContainer, DependentPropertyDirection.Out, true);
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectGlobalSymbols(propertyContainer : PropertyContainerSymbol) : void
    {
      def (direction, isInOut) = this.Modifier.Type();
      _ = propertyContainer.Node.AddAndReport.[PropertySymbol](MakeSymbol1(propertyContainer, direction, isInOut), Name.Location);
      when (isInOut)
        _ = propertyContainer.Node.AddAndReport.[PropertySymbol](MakeSymbol2(propertyContainer), Name.Location);
    }
    [Cached] MakeType() : NType = this.NitraType.Typing(this.Context)[0];
    Typing() : void
    {
      _ = MakeType();
    }
    TypeProperties() : void
    {
      when (this.PropertyValue.HasValue())
      {
        def assignment = DependentPropertyAssignment(this.Location, [Nitra.Model.Identifier(Name.Location, Symbol1.Name)], NemerleParser.Parse(this.PropertyValue, this.Context));
        TypingUtils.RegisterDependentPropertyAssignment(this.Symbol1.PropertyContainer, assignment, this.Context)
      }
    }
  }

  syntax PropertyAssignment = QualifiedName sm "=" sm Expression ";"
  {
    Typing(propertyContainer : PropertyContainerSymbol, context : Context) : void
    {
      def assignment = DependentPropertyAssignment(this.Location, this.QualifiedName.Identifiers(), NemerleParser.Parse(this.Expression, context));
      TypingUtils.RegisterDependentPropertyAssignment(propertyContainer, assignment, context)
    }
  }

  syntax StageScope = "stage" sm Number ":"
  {
    MakeContext(parent : Context) : Context = AstDependentPropertyStageContext(parent, Number.Value());
  }

  syntax SymbolDefinition = "sealed"? "symbol" outline_begin_before nl "{" inl Members=SymbolMember* d "}" outline_end_before nl
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] CalcIsTypingAllowed(value : bool) : bool = value;
    CollectSymbolMembers(astSymbol : AstSymbol, symbolSymbolRef : SymbolRef[SymbolSymbol]) : void
    {
      mutable isTypingAllowed;

      if (astSymbol.IsDeclaration)
        when (symbolSymbolRef is SymbolRef.Some(symbolSymbol))
        {
          if (symbolSymbol.Declaration : object == astSymbol)
          {
            isTypingAllowed = true;

            foreach (member in Members)
              member.CollectGlobalSymbols(symbolSymbol);
            mutable memberContext = AstDependentPropertyStageContext(this.Context, 0);
            foreach (member in Members)
              memberContext = member.MakeContext(memberContext);
          }
          else
            this.Context.Error(this.Location.FromStart(), $"Symbol definition is not allowed in declaration with inherited sealed symbol '$(symbolSymbol.FullName)'.");
        }
      else
        this.Context.Error(this.Location.FromStart(), "Symbol definition is not allowed in AST.");

      _ = CalcIsTypingAllowed(isTypingAllowed);
    }
    TypeSymbolMembers() : void
    {
      when (IsTypingAllowed)
      {
        foreach (member in Members) member.Typing();
        foreach (member in Members) member.TypeProperties()
      }
    }
  }

  syntax SymbolMember
  {
    CollectGlobalSymbols(propertyContainer : PropertyContainerSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void;
    TypeProperties() : void;

    | DependentProperty
      {
        override CollectGlobalSymbols = DependentProperty.CollectGlobalSymbols(propertyContainer);
        override MakeContext = DependentProperty.MakeContext(parent);
        override Typing = DependentProperty.Typing();
        override TypeProperties = DependentProperty.TypeProperties();
      }
    | PropertyAssignment
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(propertyContainer) }
        override Typing {}
        override TypeProperties = PropertyAssignment.Typing(this.PropertyContainer, this.Context);
      }
    | StageScope
      {
        override CollectGlobalSymbols { _ = propertyContainer; }
        override MakeContext = StageScope.MakeContext(parent);
        override Typing {}
        override TypeProperties {}
      }
  }

  syntax AstBody = outline_begin_before nl "{" inl SymbolDefinition? Members=AstMember* d "}" outline_end_before nl
  {
    IsSymbolSealed() : bool = SymbolDefinitionOpt.HasValue && SymbolDefinitionOpt.Value.KwSealedOpt.HasValue;
    CollectGlobalSymbols(owner : AstSymbol) : void = foreach (member in Members) member.CollectGlobalSymbols(owner);
    [Cached] MakeContext(parent : Context) : Context
    {
      when (SymbolDefinitionOpt.HasValue)
        _ = SymbolDefinitionOpt.Value.MakeContext(parent);
      PassThrough(Members, parent, _.MakeContext(_));
    }
    Typing() : void = foreach (member in Members) member.Typing();
    TypeProperties() : void = foreach (member in Members) member.TypeProperties();
    CollectSymbolMembers(astSymbol : AstSymbol, symbolSymbolRef : SymbolRef[SymbolSymbol]) : void
    {
      when (SymbolDefinitionOpt.HasValue)
        SymbolDefinitionOpt.Value.CollectSymbolMembers(astSymbol, symbolSymbolRef);
    }
    TypeSymbolMembers() : void
    {
      when (SymbolDefinitionOpt.HasValue)
        SymbolDefinitionOpt.Value.TypeSymbolMembers();
      foreach (member in Members)
        member.TypeSymbolMembers();
    }
  }

  syntax AstMember
  {
    CollectGlobalSymbols(owner : AstSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void;
    TypeProperties() : void;
    [Cached] Stage() : int = this.Context.TryGetContext.[AstDependentPropertyStageContext]()?.Stage;
    TypeSymbolMembers() : void {}

    | StructuralProperty = Name sm ":" sm NitraType ";" nl
      {
        private MakeSymbol(propertyContainer : PropertyContainerSymbol) : PropertySymbol = ParsedStructuralPropertySymbol(this, propertyContainer);
        override CollectGlobalSymbols
        {
          _ = owner.Node.AddAndReport.[PropertySymbol](MakeSymbol(owner), Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        [Cached] private MakeAstType() : AstType = TypingUtils.NTypeToAstType(MakeType(), this.Context);
        override Typing
        {
          _ = MakeType();
          _ = MakeAstType();
        }
        override TypeProperties {}
      }
    | DependentProperty
      {
        override CollectGlobalSymbols = DependentProperty.CollectGlobalSymbols(owner);
        override MakeContext = DependentProperty.MakeContext(parent);
        override Typing = DependentProperty.Typing();
        override TypeProperties = DependentProperty.TypeProperties();
      }
    | PropertyAssignment
      {
        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols { _ = MakePropertyContainer(owner) }
        override Typing {}
        override TypeProperties = PropertyAssignment.Typing(this.PropertyContainer, this.Context);
      }
    | Decompose = "decompose" Name outline_begin_before nl "{" inl Properties=ProjectedProperty* d "}" outline_end_before nl
      {
        syntax ProjectedProperty = Name sm ":" NitraType ";" nl
        {
          CollectGlobalSymbols(owner : PropertyContainerSymbol) : void
          {
            def symbol = ParsedProjectedPropertySymbol(this, owner);
            _ = owner.Node.AddAndReport.[PropertySymbol](symbol, Name.Location);
          }
          [Cached] MakeType() : NType = this.NitraType.Typing(this.Context)[0];
          [Cached] MakeAstType() : AstType = TypingUtils.NTypeToAstType(MakeType(), this.Context);
          [Cached] MakeContext(parent : Context) : Context = parent;
          [Cached] MakeProjectionType(t : option[PropertyProjectionType]) : option[PropertyProjectionType] = t;
          Typing() : void
          {
            _ = MakeType();
            _ = MakeAstType();
          }
          TypeProjection(projectionSource : StructuralPropertySymbol, baseType : AstSymbol) : void
          {
            _ = MakeProjectionType(MakePropertyProjectionType(this.Type, projectionSource, baseType, this.Context))
          }
        }

        [Cached] private MakePropertyContainer(propertyContainer : PropertyContainerSymbol) : PropertyContainerSymbol = propertyContainer;
        override CollectGlobalSymbols
        { 
          _ = MakePropertyContainer(owner);
          foreach (property in Properties) property.CollectGlobalSymbols(owner);
        }
        override MakeContext = FoldThrough(Properties, parent, _.MakeContext(_));
        override Typing = foreach (property in Properties) property.Typing();
        override TypeProperties
        {
          def (projectionSource, baseType) = BindAstPropertyProjectionSource(this.PropertyContainer, this.Name, this.Context);
          foreach (property in Properties) property.TypeProjection(projectionSource, baseType)
        }
      }
    | StageScope
      {
        override CollectGlobalSymbols { _ = owner; }
        override MakeContext = StageScope.MakeContext(parent);
        override Typing {}
        override TypeProperties {}
      }
    | ChildAst = "|" sm AstModifier* Name AstInheritance? Body=AstBody?
      {
        [Cached] private MakeAstSymbol(owner : AstSymbol, compilerMessages : ICompilerMessages) : ParsedChildAstSymbol
        {
          unless (owner.IsAbstract)
            compilerMessages.Error(this, "Child AST is valid only in abstract AST body.");

          def (_, _, cardinality) = TypingUtils.TypeAstModifiers(this.AstModifiers, true, owner.IsDeclaration, compilerMessages);
          ParsedChildAstSymbol(this, owner, cardinality);
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol(owner, owner.Node.Project);
          _ = owner.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          when (Body.HasValue)
            Body.Value.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          when (Body.HasValue)
          {
            def context1 = AstContext(parent, this.AstSymbol);
            def context2 = AstDependentPropertyStageContext(context1, 0);
            _ = Body.Value.MakeContext(context2);
          }
          parent
        }
        override Typing
        {
          _ = MakeBaseAsts();
          when (Body.HasValue)
            Body.Value.Typing();
        }
        override TypeProperties
        {
          this.AstSymbol.TypeInheritance();
          when (Body.HasValue)
            Body.Value.TypeProperties();
          when (this.AstSymbol.Symbol is SymbolRef.Some(s))
            s.TypeInheritance();
        }
        [Cached] private MakeBaseAsts() : list[AstSymbol] = AstSymbol.Owner :: TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol.IsDeclaration);
        override TypeSymbolMembers = when (Body.HasValue) Body.Value.TypeSymbolMembers();
      }
  }

  token AstModifier
  {
    IsAbstract(acc : bool, isExtensible : bool, compilerMessages : ICompilerMessages) : bool                                          { IgnoreParams(); acc }
    Cardinality(acc : AstCardinality, isDeclaration : bool, isAbstract : bool, compilerMessages : ICompilerMessages) : AstCardinality { IgnoreParams(); acc }

    | Abstract = "abstract" sm { override IsAbstract  = TypingUtils.TypeAstModifier_IsAbstract(this, acc, isExtensible, compilerMessages); }
    | Optional = "optional" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Optional); }
    | Multiple = "multiple" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Multiple); }
  }

  syntax NamespaceMember
  {
    CollectGlobalSymbols(ns : NamespaceSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context;
    TypeSyntaxMappings() : void {}
    TypeAst() : void {}
    Typing() : void;
    TypeSymbolMembers() : void;

    | Ast = Header sm Name AstInheritance? Body=AstBody
      {
        syntax Header
        {
          Modifiers(compilerMessages : ICompilerMessages) : bool * bool * AstCardinality;
          | Ast         = AstModifier* "ast"         { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, false, compilerMessages); }
          | Declaration = AstModifier* "declaration" { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, true,  compilerMessages); }
        }

        [Cached] private MakeAstSymbol(compilerMessages : ICompilerMessages) : AstSymbol
        {
          def (isDeclaration, isAbstract, cardinality) = this.Header.Modifiers(compilerMessages);
          if (isAbstract)
          {
            assert(cardinality == AstCardinality.Single);
            ParsedAbstractAstSymbol(this, isDeclaration)
          }
          else
            ParsedSimpleAstSymbol(this, isDeclaration, cardinality)
        }
        [Cached] private MakeBaseAsts() : list[AstSymbol] = TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol.IsDeclaration);
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol(ns.Node.Project);
          _ = ns.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          Body.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def  context1 = AstContext(parent, this.AstSymbol);
          def  context2 = AstDependentPropertyStageContext(context1, 0);
          _ = Body.MakeContext(context2);
          parent
        }
        override Typing
        {
          _ = MakeBaseAsts();
          Body.Typing();
        }
        override TypeAst
        {
          this.AstSymbol.TypeInheritance();
          Body.TypeProperties();
          when (this.AstSymbol.Symbol is SymbolRef.Some(s))
            s.TypeInheritance();
        }
        override TypeSymbolMembers = Body.TypeSymbolMembers();
      }

    | MapSyntax = "map" sm "syntax" sm RuleName=QualifiedName ParametersOpt=MapSyntaxParameters? sm "->" sm AstName=NitraType MapSyntaxBody
      {
        override CollectGlobalSymbols { _ = ns; }
        override MakeContext
        {
          def context = MapSyntaxContext(MapSyntaxEnteredScopeContext(parent));
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeParameters() : list[SyntaxMappingParameterSymbol] = if (this.ParametersOpt.HasValue) this.ParametersOpt.Value.Typing(this.Context) else [];
        [Cached] private MakeReturnType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.AstName, this.Context);
        [Cached] private MakeSymbol() : SymbolRef[SyntaxMappingSymbol]
        {
          if (this.Context.Bind.[SyntaxRuleSymbol](this.RuleName) is SymbolRef.Some(ruleSymbol))
          {
            def symbol = ParsedSyntaxMappingSymbol(this, ruleSymbol);
            ruleSymbol.AddSyntaxMapping(symbol);
            SymbolRef.Some(this.Location, false, symbol)
          }
          else SymbolRef.None(this.Location, false)
        }
        [Cached] private MakeExpr() : SyntaxMappingExpr
        {
          if (this.Symbol is SymbolRef.Some(syntaxMapping))
            this.MapSyntaxBody.TypeSyntaxMappings(syntaxMapping)
          else
            null
        }
        override Typing
        {
          _ = MakeSymbol();
          (this.Context :> MapSyntaxContext).Initialize(MakeParameters(), MakeReturnType());
        }
        override TypeSyntaxMappings
        {
          _ = MakeExpr();
        }
        override TypeSymbolMembers {}
      }

    | Namespace   = "namespace"   sm QualifiedName outline_begin_before nl "{" inl NamespaceBody      d "}" outline_end_before nl
      {
        [Cached] private MakeCurrentSymbol(ns : NamespaceSymbol) : NamespaceSymbol = MakeNamespaceSymbol(ns, QualifiedName.CalcLocations());
        override CollectGlobalSymbols = NamespaceBody.CollectGlobalSymbols(MakeCurrentSymbol(ns));
        override MakeContext
        {
          def nsContext = EnteredNamespaceContext(parent, CurrentSymbol);
          _ = NamespaceBody.MakeContext(nsContext);
          parent
        }
        override TypeSyntaxMappings = NamespaceBody.TypeSyntaxMappings();
        override Typing = NamespaceBody.Typing();
        override TypeAst = NamespaceBody.TypeAst();
        override TypeSymbolMembers = NamespaceBody.TypeSymbolMembers();
      }

    | SyntaxModule = SyntaxModuleAttributes "syntax" sm "module"sm Name outline_begin_before nl "{" inl Usings SyntaxModuleMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols
        {
          def symbol = ParsedSyntaxModuleSymbol(this);
          _ = ns.Node.AddAndReport(symbol, Name.Location);
          foreach (decl in SyntaxModuleMembers)
            decl.CollectGlobalSymbols(symbol);
        }
        [Cached] private MakeInitialContext(contextToSave : SyntaxModuleContext) : SyntaxModuleContext = contextToSave;
        [Cached] private MakeFinalContext(contextToSave : Context) : Context = contextToSave;
        override MakeContext
        {
          def context1 = MakeInitialContext(SyntaxModuleContext(parent, Name));
          def context2 = Usings.MakeContext(context1);
          def context3 = SyntaxModuleBodyContext(context2);
          def finalContext = MakeFinalContext(FoldThrough(SyntaxModuleMembers, context3, _.MakeContext(_)));
          Utils.RegisterGlobalSpanClassSymbols(context1.SyntaxModuleSymbol, finalContext);
          parent
        }
        [Cached] private MakeTokenLiteralNames() : Map[string, Nitra.Model.Identifier] = FoldThrough(SyntaxModuleMembers, Map(), _.GetTokenLiteralNames(_));
        override TypeSyntaxMappings    = foreach (decl in SyntaxModuleMembers) decl.TypeSyntaxMappings();
        override Typing
        {
          _ = MakeTokenLiteralNames();
          foreach (decl in SyntaxModuleMembers)
            decl.Typing();
        }
        override TypeSymbolMembers {}
      }
  }

  syntax SyntaxModuleAttribute
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | ExplicitSpaces = AttributeName="ExplicitSpaces" { override Options = inOptions.SetExplicitSpaces(this, true); }
    | ImplicitSpaces = AttributeName="ImplicitSpaces" { override Options = inOptions.SetExplicitSpaces(this, false); }
  }

  syntax SyntaxModuleAttributeList = "[" (SyntaxModuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax SyntaxModuleAttributes    = SyntaxModuleAttributeList*
  {
    [Cached] Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributeLists, parent, _.MakeContext(_));
  }

  syntax RuleAttribute
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | Start                  = AttributeName="StartRule" { override Options = inOptions.SetStart(this, true); }
    | "Arity" "(" Number ")" { override Options = inOptions.SetArity(this, Number.Value()); }
    | "Prefix"               { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Prefix); }
    | "Postfix"              { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Postfix); }
    | "Infix"                { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Infix); }
    | SpanClass              = AttributeName="SpanClass" "(" Class=Identifier ")"
      {
        override Options = Context.Bind.[SpanClassSymbol](Class).Map(inOptions.SetSpanClass(Class, _)) ?? inOptions;
      }
    | ExplicitSpaces              = AttributeName="ExplicitSpaces"              { override Options = inOptions.SetExplicitSpaces(this, true); }
    | ImplicitSpaces              = AttributeName="ImplicitSpaces"              { override Options = inOptions.SetExplicitSpaces(this, false); }
    | SuppressTrailingSpaces      = AttributeName="SuppressTrailingSpaces"      { override Options = inOptions.SetSuppressTrailingSpaces(this, true); }
    | AllowTrailingSpaces         = AttributeName="AllowTrailingSpaces"         { override Options = inOptions.SetSuppressTrailingSpaces(this, false); }
    | NoParseTree                 = AttributeName="NoParseTree"                 { override Options = inOptions.SetNoParseTree(this, true); }
    | KeyToken                    = AttributeName="Key"                         { override Options = inOptions.SetKeyToken(this, true); }
    | Keyword                     = AttributeName="Keyword"                     { override Options = inOptions.SetKeyword(this, true); }
    | Reference                   = AttributeName="Reference"                   { override Options = inOptions.SetReference(this, true); }
    | Name                        = AttributeName="Name"                        { override Options = inOptions.SetName(this, true); }
    | DynamicSyntaxExtender       = AttributeName="DynamicSyntaxExtender"       { override Options = inOptions.SetDynamicSyntaxExtender(this, true); }
    | DynamicSyntaxExtentionPoint = AttributeName="DynamicSyntaxExtentionPoint" { override Options = inOptions.SetDynamicSyntaxExtentionPoint(this, true); }
  }

  syntax RuleAttributeList = "[" (RuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(RuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax RuleAttributes    = RuleAttributeList*
  {
    [Cached] Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(RuleAttributeLists, parent, _.MakeContext(_));
  }

  [StartRule]
  syntax SyntaxModuleMember
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetPrecedenceRelations() : PrecedenceRelations * list[Precedence] = (null, null);
    TypeSyntaxMappings() : void {}
    Typing() : void {}

    GetTokenLiteralNames(result : Map[string, Nitra.Model.Identifier]) : Map[string, Nitra.Model.Identifier] = result;

    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(owner);
        override MakeContext          = RegexRule.MakeContext(parent);
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(owner);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols    = ExtensibleRule.CollectGlobalSymbols(owner);
        override MakeContext             = ExtensibleRule.MakeContext(parent);
        override GetPrecedenceRelations  = ExtensibleRule.PrecedenceRelations;
        override TypeSyntaxMappings      = ExtensibleRule.TypeSyntaxMappings();
        override Typing                  = ExtensibleRule.Typing();
      }
    | Marker              = "marker"              sm Name                                                   ";"nl
      {
        override CollectGlobalSymbols = _ = owner.Node.AddAndReport(ParsedMarkerSymbol(Name, owner), Location);
      }
    | ExtendRule          = Header sm (Name sm "=" sm)? BaseName=QualifiedName RuleBody
      {
        syntax Header
        {
          IsToken() : bool;
          | Token  = "extend" sm "token"  { override IsToken = true;  }
          | Syntax = "extend" sm "syntax" { override IsToken = false; }
        }

        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtendSyntaxSymbol = ParsedExtendSyntaxSymbol(this, owner, this.Header.IsToken());
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          _ = owner.Node.AddAndReport.[ExtendSyntaxSymbol](symbol, Location);
          this.RuleBody.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context1 = RuleParametersContext(parent);
          def context2 = RuleDeclarationSiteContext(context1, this.Symbol);
          _ = this.RuleBody.MakeContext(PrecedenceZeroContext(PrecedenceStartContext(context2, this.Symbol)));
          context1
        }
        [Cached] private MakePrecedenceRelationsCached(context : Context) : PrecedenceRelations * list[Precedence]
        {
          PrecedenceContext.MakePrecedenceRelations(context)
        }
        override GetPrecedenceRelations = PrecedenceRelationsCached;
        override TypeSyntaxMappings     = this.RuleBody.TypeSyntaxMappings();
        [Cached] private MakeBaseRuleRef() : SymbolRef[ExtensibleRuleSymbol] = this.Context.Bind.[ExtensibleRuleSymbol](BaseName);
        override Typing
        {
          def baseRule = MakeBaseRuleRef();
          when (baseRule is Some(symbol))
          {
            def context = this.Context.GetContext.[RuleParametersContext]();
            context.Initialize(symbol.Parameters);

            when (symbol.Options.IsTokenRule != this.Symbol.IsToken)
            {
              def msg = if (symbol.Options.IsTokenRule) "Can't extend token with syntax rule."
                        else "Can't extend syntax rule with token.";
              this.Context.Error(BaseName, msg);
            }
          }
          this.RuleBody.Typing();
          _ = MakePrecedenceRelationsCached(this.RuleBody.Context);
        }
      }
    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | TokenLiteral        = "literal"             sm Name  sm "="  sm (StringLiteral; ","sm)+               ";"nl
      {
        override GetTokenLiteralNames
        {
          def name = Name.Identifier();
          FoldThrough(StringLiterals.Item1, result, (strLit, result) => result.Replace(strLit.Value(), name))
        }
        override MakeContext = TokenLiteralContext(parent, Name, StringLiterals.Item1);
      }
    | SpanClass           = "span"    sm "class"  sm Name MatchTokens=("=" RegexExpression)?                ";"nl
      {
        [Cached] private MakeSymbol(context : Context) : SpanClassSymbol
        {
          def symbol = ParsedSpanClassSymbol(this, context);
          context.Project.AddSymbolDef(symbol, Name.Location);
          symbol
        }
        [Cached] private RegularRule() : option[RegularRule] = MatchTokens.Map(t =>
        {
          def rr = t.Item2.Typing();
          rr.ValidateRegularRule(this.Context);
          rr
        });
        override MakeContext
        {
          def context = SpanClassContext(parent, MakeSymbol(parent));
          _ = MatchTokens.Map(t => t.Item2.MakeContext(context));
          context
        }
        override Typing { _ = RegularRule(); }
      }
    | KeywordRegex        = "keyword" sm "regex"  sm MatchTokens=RegexExpression sm "rule" sm QualifiedName ";"nl
      {
        override MakeContext
        {
          def context = KeywordRegexContext(parent, MatchTokens, QualifiedName);
          _ = MatchTokens.MakeContext(context);
          context
        }
      }
  }

  syntax RuleAlias = "alias" sm Name sm "=" sm RuleExpression ";"nl
  {
    [Cached] private MakeSymbol(project : Project) : RuleAliasSymbol
    {
      def symbol = ParsedRuleAliasSymbol(this);
      project.AddSymbolDef(symbol, Name.Location);
      symbol
    }
    MakeContext(parent : Context) : Context = RuleAliasContext(parent, MakeSymbol(parent.Project));
  }

  syntax MapSyntaxCode
  {
    MakeExpr(context : Context) : SyntaxMappingExpr = SyntaxMappingExpr.Code(this, NemerleParser.Parse(this, context));
    | Block
    | Expression = Expression ";"
  }

  syntax MapSyntaxExpression
  {
    [Cached] MakeContext(parent : Context) : Context;
    [Cached] MakeType(ruleSymbol : SyntaxRuleSymbol, typeHintOpt : ValueOption[AstType]) : SyntaxMappingType;
    Expression(ruleSymbol : SyntaxRuleSymbol, astType : AstType) : SyntaxMappingExpr = SyntaxMappingTyper.MakeExpression(MakeType(ruleSymbol, VSome(astType)), astType, this.Context);

    | Braces = "(" Expr=MapSyntaxExpression ")"
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override MakeType   = this.Expr.MakeType(ruleSymbol, typeHintOpt);
      }
    | Identifier = !(ReservedWords !IdentifierPartCharacters) Identifier
      {
        regex ReservedWords = "Some" | "None";
        override MakeContext = parent;
        override MakeType    = SyntaxMappingTyper.TypeIdentifier(this, ruleSymbol, typeHintOpt);
      }
    | Ast        = QualifiedName outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxExpressionAstMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext { foreach (member in this.Members) _ = member.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeAst(this, ruleSymbol, typeHintOpt);
      }
    | List       = "[" (ItemExpr=MapSyntaxExpression; ",")* "]"
      {
        override MakeContext { foreach (member in this.ItemExprs.Item1) _ = member.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeList(this, ruleSymbol, typeHintOpt);
      }
    | OptionSome = "Some" "(" ValueExpr=MapSyntaxExpression ")"
      {
        override MakeContext { _ = ValueExpr.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeOptionSome(this, ruleSymbol, typeHintOpt);
      }
    | OptionNone = "None" "(" ")"
      {
        override MakeContext = parent;
        override MakeType    { IgnoreParams(); SyntaxMappingType.Option(this.Location, None()); }
      }
    | Match = "match" "(" Expr=MapSyntaxExpression ")" outline_begin_before nl "{" inl ("|" sm)? (MatchCase; inl "|")+ "}" outline_end_before nl
      {
        syntax MatchCase = Pattern sm "->" Expr=MapSyntaxExpression
        {
          [Cached] MakeContext(parent : Context) : Context
          {
            def context = ParseTreePatternVariableContext(parent);
            _ = this.Expr.MakeContext(context);
            context
          }
          MakeType(ruleType : RuleType, ruleSymbol : SyntaxRuleSymbol, typeHintOpt : ValueOption[AstType]) : Location * ParseTreePattern * SyntaxMappingType
          {
            def patternType = this.Pattern.Typing(ruleType, this.Context);
            def exprType    = this.Expr.MakeType(ruleSymbol, typeHintOpt);
            (this.Location, patternType, exprType)
          }
        }

        override MakeContext { _ = this.Expr.MakeContext(parent); foreach (item in this.MatchCases.Item1) _ = item.MakeContext(parent); parent }
        override MakeType = SyntaxMappingTyper.TypeMatch(this, ruleSymbol, typeHintOpt);
      }
    | Fold = "fold" "(" ItemName=Identifier            sm "in" sm ItemExpr=MapSyntaxExpression
                    ";" sm AccumulatorName1=Identifier sm "="  sm InitExpr=MapSyntaxExpression
                    ";" sm AccumulatorName2=Identifier sm "="  sm EachExpr=MapSyntaxExpression
                    ")"
      {
        [Cached] private MakeAccumulatorSymbol() : AstVariableSymbol = ParsedAccumulatorAstVariableSymbol(this);
        override MakeContext
        {
          _ = ItemExpr.MakeContext(parent);
          _ = InitExpr.MakeContext(parent);

          def context1 = ParseTreePatternVariableContext(parent);
          def context2 = AstVariableContext(context1, MakeAccumulatorSymbol());
          _ = EachExpr.MakeContext(context2);
          parent
        }
        [Cached] private MakeReturnType(returnType : AstType) : AstType = returnType;
        override MakeType = SyntaxMappingTyper.TypeFold(this, ruleSymbol, typeHintOpt);
      }
    | DefineVariable = "let" sm Name sm ":" sm NitraType sm "=" sm Expr=MapSyntaxExpression sm "in" nl Body=MapSyntaxExpression
      {
        [Cached] private MakeVariableSymbol() : AstVariableSymbol = ParsedAstVariableSymbol(this);
        [Cached] private MakeVariableType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.NitraType, this.Context);
        [Cached] private MakeVariableExpression(ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingExpr = Expr.Expression(ruleSymbol, MakeVariableType());
        override MakeContext
        {
          def context = AstVariableContext(parent, MakeVariableSymbol());
          _ = Expr.MakeContext(context);
          Body.MakeContext(context)
        }
        override MakeType
        {
          _ = MakeVariableExpression(ruleSymbol);
          def body = Body.MakeType(ruleSymbol, typeHintOpt);
          SyntaxMappingType.DefineVariable(this, this.VariableSymbol, body)
        }
      }

    precedence TypeHint:
    | TypeHint = Expr=MapSyntaxExpression sm ":" sm NitraType
      {
        override MakeContext = Expr.MakeContext(parent);
        override MakeType    = SyntaxMappingTyper.TypeTypeHint(this, ruleSymbol, typeHintOpt);
      }

    precedence Call:
    | Call = Expr=MapSyntaxExpression "(" (ArgumentExpr=MapSyntaxExpression; "," sm)* ")"
      {
        override MakeContext { _ = Expr.MakeContext(parent); foreach (item in ArgumentExprs.Item1) _ = item.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeCall(this, ruleSymbol, typeHintOpt);
      }

    precedence MemberAccess:
    | MemberAccess = Expr=MapSyntaxExpression "." Identifier
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override MakeType    = SyntaxMappingTyper.TypeMemberAccess(this, ruleSymbol, typeHintOpt);
      }
  }

  syntax MapSyntaxExpressionAstMember
  {
    MakeContext(parent : Context) : Context;
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol) : ValueOption[SyntaxMappingField];

    | ParseTreeFieldExpressionMapping
      {
        override MakeContext = ParseTreeFieldExpressionMapping.MakeContext(parent);
        override GetSyntaxMappingField = ParseTreeFieldExpressionMapping.GetSyntaxMappingField(astSymbol, ruleSymbol);
      }
    | ParseTreeFieldCodeMapping
      {
        override MakeContext = ParseTreeFieldCodeMapping.MakeContext(parent);
        override GetSyntaxMappingField = ParseTreeFieldCodeMapping.GetSyntaxMappingField(astSymbol, ruleSymbol);
      }
  }

  syntax ParseTreeFieldExpressionMapping = Expr=MapSyntaxExpression sm "->" sm AstPropertyName=Name ";"
  {
    [Cached] MakeContext(parent : Context) : Context { _ = Expr.MakeContext(parent); parent }
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol) : ValueOption[SyntaxMappingField]
    {
      match (TypingUtils.BindProperty(astSymbol, this.AstPropertyName, this.Context))
      {
        | SymbolRef.Some(StructuralPropertySymbol(AstType = Void) as p) =>
          def name = p.Name;
          def type = p.Type;
          this.Context.Error(this, $"Type '$type' of property '$name' is not AST.");
          VNone()

        | SymbolRef.Some(StructuralPropertySymbol as p) =>
          def expr = this.Expr.Expression(ruleSymbol, p.AstType);
          VSome(SyntaxMappingField(this.Location, p, expr))

        | SymbolRef.Some =>
          this.Context.Error(this, "Expected structural AST property.");
          VNone()

        | SymbolRef.None => VNone()
      }
    }
  }

  syntax ParseTreeFieldCodeMapping = FieldName=Name sm "=" sm Code=MapSyntaxCode
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetSyntaxMappingField(astSymbol : AstSymbol, _ruleSymbol : SyntaxRuleSymbol) : ValueOption[SyntaxMappingField]
    {
      match (TypingUtils.BindProperty(astSymbol, this.FieldName, this.Context))
      {
        | SymbolRef.Some(StructuralPropertySymbol as p) =>
          def expr = this.Code.MakeExpr(this.Context);
          VSome(SyntaxMappingField(this.Location, p, expr))

        | SymbolRef.Some =>
          this.Context.Error(this, "Expected structural AST property.");
          VNone()

        | SymbolRef.None => VNone()
      }
    }
  }

  syntax MapSyntaxBodyMember
  {
    [Cached] MakeContext(parent : Context) : Context;
    CollectMappingFields(syntaxMapping : SyntaxMappingSymbol, buffer : List[SyntaxMappingField]) : void { IgnoreParams() }
    CollectSimpleMatchCases(syntaxMapping : SyntaxMappingSymbol, sharedMappingFields : List[SyntaxMappingField], buffer : List[SyntaxMappingCase]) : void { IgnoreParams() }
    CollectExtensionBodies(astType : AstType, baseRuleSymbol : ExtensibleRuleSymbol, mappingCases : List[ExtensionRuleSymbol * SyntaxMappingCase], mappingBodies : List[ExtensionRuleSymbol * SyntaxMappingExpr]) : void { IgnoreParams() }

    | ParseTreeFieldExpressionMapping
      {
        override MakeContext          = ParseTreeFieldExpressionMapping.MakeContext(parent);
        override CollectMappingFields
        {
          if (syntaxMapping.ReturnType is AstType.Ast(astSymbol))
            when (ParseTreeFieldExpressionMapping.GetSyntaxMappingField(astSymbol, syntaxMapping.DeclaringRule) is VSome(mappingField))
              buffer.Add(mappingField);
          else
          {
            def t = syntaxMapping.ReturnType;
            this.Context.Error(this, $"Field mapping is not valid on AST type '$t'.");
          }
        }
      }
    | ParseTreeFieldCodeMapping
      {
        override MakeContext          = ParseTreeFieldCodeMapping.MakeContext(parent);
        override CollectMappingFields
        {
          if (syntaxMapping.ReturnType is AstType.Ast(astSymbol))
            when (ParseTreeFieldCodeMapping.GetSyntaxMappingField(astSymbol, syntaxMapping.DeclaringRule) is VSome(mappingField))
              buffer.Add(mappingField);
          else
          {
            def t = syntaxMapping.ReturnType;
            this.Context.Error(this, $"Field mapping is not valid on AST type '$t'.");
          }
        }
      }
    | MatchCase = "|" sm Pattern Body=MatchCaseBody
      {
        override MakeContext
        {
          def context = ParseTreePatternVariableContext(parent);
          _ = Body.MakeContext(context);
          context
        }
        override CollectSimpleMatchCases  = Body.CollectSimpleMatchCases(this.Pattern, syntaxMapping, sharedMappingFields, buffer);
        override CollectExtensionBodies   = Body.CollectExtensionBodies(this.Pattern, astType, baseRuleSymbol, mappingCases, mappingBodies);
      }
  }

  syntax MatchCaseBody
  {
    [Cached] MakeContext(parent : Context) : Context;
    CollectSimpleMatchCases(pattern : Pattern, syntaxMapping : SyntaxMappingSymbol, sharedMappingFields : List[SyntaxMappingField], buffer : List[SyntaxMappingCase]) : void;
    CollectExtensionBodies(pattern : Pattern, astType : AstType, baseRuleSymbol : ExtensibleRuleSymbol, mappingCases : List[ExtensionRuleSymbol * SyntaxMappingCase], mappingBodies : List[ExtensionRuleSymbol * SyntaxMappingExpr]) : void;

    | Expression = sm "->" sm Expr=MapSyntaxExpression
      {
        override MakeContext { _ = Expr.MakeContext(parent); parent }
        override CollectSimpleMatchCases
        {
          _ = sharedMappingFields;
          def patternExpr = pattern.SimpleTyping(syntaxMapping.DeclaringRule, this.Context);
          def expr        = this.Expr.Expression(syntaxMapping.DeclaringRule, syntaxMapping.ReturnType);
          buffer.Add(SyntaxMappingCase(this.Location, patternExpr, expr))
        }
        override CollectExtensionBodies
        {
          match (pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), true) =>
              def patternExpr = pattern.ExtensionTyping(ruleSymbol, this.Context);
              def expr        = this.Expr.Expression(ruleSymbol, astType);
              mappingCases.Add((ruleSymbol, SyntaxMappingCase(this.Location, patternExpr, expr)))

            | (SymbolRef.Some(ruleSymbol), false) =>
              def expr = this.Expr.Expression(ruleSymbol, astType);
              mappingBodies.Add((ruleSymbol, expr))

            | _ => ()
          }
        }
      }
    | PerField = outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxExpressionAstMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext { foreach (member in Members) _ = member.MakeContext(parent); parent }
        [Cached] private MakeAstSymbolRef(pattern : Pattern) : SymbolRef[AstSymbol] = pattern.BindExtensionAst(this.Context);
        private CreateSyntaxMappingExpr(ruleSymbol : SyntaxRuleSymbol, astSymbol : AstSymbol, sharedMappingFields : List[SyntaxMappingField]) : SyntaxMappingExpr
        {
          def mappingFields = List();
          when (sharedMappingFields != null)
            mappingFields.AddRange(sharedMappingFields);

          foreach (member in this.Members)
            when (member.GetSyntaxMappingField(astSymbol, ruleSymbol) is VSome(mappingField))
              mappingFields.Add(mappingField);

          TypingUtils.CreateAstCtor(this, astSymbol, mappingFields, Location(this.Location.Source, this.CloseBrace), this.Context)
        }
        override CollectSimpleMatchCases
        {
          if (syntaxMapping.ReturnType is AstType.Ast)
          {
            def patternExpr      = pattern.SimpleTyping(syntaxMapping.DeclaringRule, this.Context);
            def caseAstSymbolRef = MakeAstSymbolRef(pattern);
            when (caseAstSymbolRef is SymbolRef.Some(caseAstSymbol))
            {
              def expr = CreateSyntaxMappingExpr(syntaxMapping.DeclaringRule, caseAstSymbol, sharedMappingFields);
              buffer.Add(SyntaxMappingCase(this.Location, patternExpr, expr))
            }
          }
          else
          {
            def t = syntaxMapping.ReturnType;
            this.Context.Error(this, $"Short syntax is not valid on AST type '$t'.");
          }
        }
        override CollectExtensionBodies
        {
          if (astType is AstType.Ast)
          {
            def (ruleRef, hasPattern) = pattern.BindExtensionRule(baseRuleSymbol, this.Context);
            when (ruleRef is SymbolRef.Some(ruleSymbol))
            {
              def extensionAstSymbolRef = MakeAstSymbolRef(pattern);
              when (extensionAstSymbolRef is SymbolRef.Some(extensionAstSymbol))
              {
                if (hasPattern)
                {
                  def patternExpr = pattern.ExtensionTyping(ruleSymbol, this.Context);
                  def expr        = CreateSyntaxMappingExpr(ruleSymbol, extensionAstSymbol, null);
                  mappingCases.Add((ruleSymbol, SyntaxMappingCase(this.Location, patternExpr, expr)))
                }
                else
                {
                  def expr        = CreateSyntaxMappingExpr(ruleSymbol, extensionAstSymbol, null);
                  mappingBodies.Add((ruleSymbol, expr))
                }
              }
            }
          }
          else
            this.Context.Error(this, $"Short syntax is not valid on AST type '$astType'.");
        }
      }
    | Inline = sm "=" sm Code=MapSyntaxCode
      {
        override MakeContext = parent;
        override CollectSimpleMatchCases
        {
          _ = sharedMappingFields;
          def patternExpr = pattern.SimpleTyping(syntaxMapping.DeclaringRule, this.Context);
          def expr        = this.Code.MakeExpr(this.Context);
          buffer.Add(SyntaxMappingCase(this.Location, patternExpr, expr))
        }
        override CollectExtensionBodies
        {
          _ = astType;
          match (pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), true)  => mappingCases.Add((ruleSymbol, SyntaxMappingCase(this.Location, pattern.ExtensionTyping(ruleSymbol, this.Context), this.Code.MakeExpr(this.Context))))
            | (SymbolRef.Some(ruleSymbol), false) => mappingBodies.Add((ruleSymbol, this.Code.MakeExpr(this.Context)))
            | _ => ()
          }
        }
      }
  }

  syntax Pattern
  {
    [Cached] BindExtensionRule(baseRuleSymbol : ExtensibleRuleSymbol, context : Context) : SymbolRef[ExtensionRuleSymbol] * bool
    {
      _ = baseRuleSymbol;
      context.Error(this, "Extension rule pattern expected");
      (SymbolRef.None(this.Location, true), false)
    }
    BindExtensionAst(context : Context) : SymbolRef[AstSymbol]
    {
      context.Error(this, "Extension rule pattern expected");
      SymbolRef.None(this.Location, true)
    }
    ExtensionTyping(ruleSymbol : ExtensionRuleSymbol, context : Context) : ParseTreePattern
    {
      IgnoreParams();
      assert(false)
    }
    SimpleTyping(ruleSymbol : SyntaxRuleSymbol, context : Context) : ParseTreePattern
    {
      PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, ConcreteListParseTree(this.Location, array[this]), context);
    }
    Typing(ruleType : RuleType, context : Context) : ParseTreePattern;

    | Identifier
      {
        override BindExtensionRule        = (Utils.BindByHierarchy.[ExtensionRuleSymbol](baseRuleSymbol, this.Identifier, context), false);
        override BindExtensionAst         = TypingUtils.BindAstSymbolFromMappingExtension(this.Identifier.Location, [this.Identifier.Location], context);
        override Typing                   = PatternTyper.TypeIdentifier(this.Location, this.Identifier.Identifier(), ruleType, context);
      }
    | Ctor  = Identifier "(" (Pattern; "," sm)* ")"
      {
        override BindExtensionRule        = (Utils.BindByHierarchy.[ExtensionRuleSymbol](baseRuleSymbol, this.Identifier, context), true);
        override BindExtensionAst         = TypingUtils.BindAstSymbolFromMappingExtension(this.Identifier.Location, [this.Identifier.Location], context);
        override Typing                   = PatternTyper.TypeCtor(this.Location, this.Identifier.Identifier(), this.Patterns.Item1, ruleType, context);
        override ExtensionTyping          = PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, this.Patterns.Item1, context);
      }
    | Tuple = "(" (Pattern; "," sm)* ")"
      {
        override Typing       = PatternTyper.TypeTuple(this.Location, this.Patterns.Item1, ruleType, context);
        override SimpleTyping = PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, this.Patterns.Item1, context);
      }

    precedence List:
    | List1 = Pattern ^ List s "::" s Pattern ^ +List
      {
        override Typing = PatternTyper.TypeList1(this.Location, this.Pattern1, this.Pattern2, ruleType, context);
      }
    precedence 0:

    | List2 = "[" (Pattern; "," sm)* "]"
      {
        override Typing = PatternTyper.TypeList2(this.Location, this.Patterns.Item1, ruleType, context);
      }
  }

  syntax MapSyntaxParameters = "(" (RuleMethodParam; "," sm)* ")"
  {
    Typing(context : Context) : list[SyntaxMappingParameterSymbol] = this.RuleMethodParams.Item1.MapToList(_.TypeForMapSyntax(context));
  }

  syntax MapSyntaxBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    TypeSyntaxMappings(syntaxMapping : SyntaxMappingSymbol) : SyntaxMappingExpr;

    | Empty = ";"
      {
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
            null
          else match (syntaxMapping.ReturnType)
          {
            | Ast(astSymbol)        => TypingUtils.CreateAstCtor(this, astSymbol, [], this.Location, this.Context)
            | List(astSymbol)
            | OptionList(astSymbol) => SyntaxMappingExpr.ListCtor(this.Location, astSymbol, [])
            | Option(astSymbol)     => SyntaxMappingExpr.OptionCtor(this.Location, astSymbol, None())
            | Void                  => SyntaxMappingExpr.Error(this)
          }
        }
      }
    | Expression = outline_begin_before nl "{" Expr=MapSyntaxExpression "}" outline_end_before nl
      {
        override MakeContext { _ = this.Expr.MakeContext(parent); parent }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol)
          {
            this.Context.Error(this, "Mapping expression is not valid on extensible rules");
            null
          }
          else
            this.Expr.Expression(syntaxMapping.DeclaringRule, syntaxMapping.ReturnType)
        }
      }
    | Inline = sm "=" sm Code=MapSyntaxCode
      {
        override TypeSyntaxMappings { _ = syntaxMapping; this.Code.MakeExpr(this.Context); }
      }
    | PerMember = outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxBodyMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext
        {
          def context = parent;
          foreach (member in Members)
            _ = member.MakeContext(context);
          context
        }
        override TypeSyntaxMappings
        {
          if (syntaxMapping.DeclaringRule is ExtensibleRuleSymbol as baseRuleSymbol)
          {
            def mappingCases  = List();
            def mappingBodies = List();
            foreach (member in Members)
              member.CollectExtensionBodies(syntaxMapping.ReturnType, baseRuleSymbol, mappingCases, mappingBodies);

            foreach ((extensionRuleSymbol, expr) in mappingBodies)
            {
              def symbol = ChemicalSyntaxMappingSymbol(extensionRuleSymbol, syntaxMapping.Parameters, syntaxMapping.ReturnType, expr);
              extensionRuleSymbol.AddSyntaxMapping(symbol);
            }

            foreach (item in mappingCases.GroupBy(tup => tup[0], tup => tup[1]))
            {
              def extensionRuleSymbol = item.Key;
              def mappingCases        = NList.ToList(item);
              def path                = ParseTreePath.This(this.Location, extensionRuleSymbol);
              def expr                = SyntaxMappingExpr.Match(this.Location, path, mappingCases, syntaxMapping.ReturnType);
              def symbol              = ChemicalSyntaxMappingSymbol(extensionRuleSymbol, syntaxMapping.Parameters, syntaxMapping.ReturnType, expr);
              extensionRuleSymbol.AddSyntaxMapping(symbol)
            }
            null
          }
          else
          {
            def mappingFields = List();
            foreach (member in Members)
              member.CollectMappingFields(syntaxMapping, mappingFields);

            def mappingCases = List();
            foreach (member in Members)
              member.CollectSimpleMatchCases(syntaxMapping, mappingFields, mappingCases);

            if (mappingCases.Count > 0)
            {
              def path = ParseTreePath.This(this.Location, syntaxMapping.DeclaringRule);
              SyntaxMappingExpr.Match(this.Location, path, mappingCases.ToNList(), syntaxMapping.ReturnType)
            }
            else match (syntaxMapping.ReturnType)
            {
              | Ast(astSymbol) => TypingUtils.CreateAstCtor(this, astSymbol, mappingFields, Location(this.Location.Source, this.CloseBrace), this.Context)
              | List(astSymbol)
              | OptionList(astSymbol) => SyntaxMappingExpr.ListCtor(this.Location, astSymbol, [])
              | Option(astSymbol)     => SyntaxMappingExpr.OptionCtor(this.Location, astSymbol, None())
              | Void                  => SyntaxMappingExpr.Error(this)
            }
          }
        }
      }
  }

  syntax RegexRule = RuleAttributes "regex" sm Name RuleParameters? sm "=" sm RegexExpression RuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedRegularRuleSymbol
    {
      def parameters = 
        if (RuleParametersOpt.HasValue)
          RuleParametersOpt.Value.GetSymbols().ToNList();
        else
          [];
      ParsedRegularRuleSymbol(this, owner, parameters)
    }
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol => owner.Node.Project.Error(this, "Regular rule declaration is not allowed here.")
        | _ => ()
      }
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context1 = RuleParametersContext(parent, this.Symbol.Parameters);
      def context2 = RuleDeclarationSiteContext(context1, this.Symbol);
      _ = this.RuleAttributes.MakeContext(context2);
      _ = this.RegexExpression.MakeContext(context2);
      _ = this.RuleBody.MakeContext(context2);
      context1
    }
    [Cached] private Regex() : RegularRule = RegexExpression.Typing();
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void
    {
      _ = Regex();
      _ = this.RuleBody.Typing();
    }
  }

  syntax RuleParameter = Kind Name
  {
    regex Kind = "regex" | "syntax" | "token";

    [Cached] GetSymbol() : RuleParameterSymbol
    {
      ParsedRuleParameterSymbol(this)
    }
  }

  syntax RuleParameters = "<" (Parameter=RuleParameter; "," sm)+ ">"
  {
    GetSymbols() : List[RuleParameterSymbol]
    {
      def result = List();
      foreach (ruleParameter in Parameters.Item1)
        result.Add(ruleParameter.GetSymbol());
      result
    }
  }

  syntax SimpleRule = RuleAttributes Header sm Name RuleParameters? sm "=" sm RuleExpression RuleBody
  {
    token Header
    {
      Kind() : SimpleRuleKind; Title() : string;
      | Syntax = "syntax" { override Kind = SimpleRuleKind.Normal; override Title = "Simple rule"; }
      | Token  = "token"  { override Kind = SimpleRuleKind.Token;  override Title = "Token rule"; }
      | Void   = "void"   { override Kind = SimpleRuleKind.Void;   override Title = "Void rule"; }
    }

    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : SimpleRuleSymbol
    {
      def parameters = 
        if (RuleParametersOpt.HasValue)
          RuleParametersOpt.Value.GetSymbols().ToNList();
        else
          [];

      match (this.Header.Kind())
      {
        | Normal => ParsedSimpleRuleSymbol(this, owner, parameters)
        | Token  => ParsedTokenRuleSymbol (this, owner, parameters)
        | Void   => ParsedVoidRuleSymbol  (this, owner);
      }
    }
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol
        | RegularRuleSymbol
        | SimpleRuleSymbol(Kind = SimpleRuleKind.Token) when this.Header.Kind() != SimpleRuleKind.Token =>
          def title = this.Header.Title();
          owner.Node.Project.Error(this, $"$title declaration is not allowed here.")

        | _ => ()
      }

      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context1 = RuleParametersContext(parent, this.Symbol.Parameters);
      def context2 = RuleDeclarationSiteContext(context1, Symbol);
      _ = this.RuleAttributes.MakeContext(context2);
      _ = this.RuleBody.MakeContext(context2);
      context1
    }
    [Cached] private MakeTypedRule()   : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, this.RuleBody.Context, RuleExpression.Typing(None(), PrecedenceInfo.None, None(), this.RuleBody.Context, this.Symbol.Options));
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void
    {
      _ = MakeTypedRule();
      this.RuleBody.Typing();
    }
  }

  syntax ExtensibleRule = RuleAttributes Header sm Name RuleParameters? RuleBody
  {
    token Header
    {
      IsToken() : bool; Title() : string;
      | Syntax = "syntax" { override IsToken = false; override Title = "Extensible rule"; }
      | Token  = "token"  { override IsToken = true;  override Title = "Extensible token rule"; }
    }

    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ExtensibleRuleSymbol
    {
      def parameters = 
        if (RuleParametersOpt.HasValue)
          RuleParametersOpt.Value.GetSymbols().ToNList();
        else
          [];

      if (this.Header.IsToken())
        ParsedExtensibleTokenRuleSymbol(this, owner, parameters)
      else
        ParsedExtensibleRuleSymbol(this, owner, parameters)
    }
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      match (owner : object)
      {
        | ExtendSyntaxSymbol
        | RegularRuleSymbol
        | SimpleRuleSymbol(Kind = SimpleRuleKind.Token) when !this.Header.IsToken() =>
          def title = this.Header.Title();
          owner.Node.Project.Error(this, $"$title declaration is not allowed here.")

        | _ => ()
      }
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, this.Location);
      this.RuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context1 = RuleParametersContext(parent, this.Symbol.Parameters);
      def context2 = RuleDeclarationSiteContext(context1, this.Symbol);
      _ = this.RuleAttributes.MakeContext(context2);
      _ = MakePrecedenceRelations(this.RuleBody.MakeContext(PrecedenceZeroContext(PrecedenceStartContext(context2, this.Symbol))));
      context1
    }
    [Cached]
    MakePrecedenceRelations(context : Context) : PrecedenceRelations * list[Precedence]
    {
      PrecedenceContext.MakePrecedenceRelations(context)
    }
    TypeSyntaxMappings() : void    = this.RuleBody.TypeSyntaxMappings();
    Typing() : void                = this.RuleBody.Typing();
  }

  syntax RuleBody
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_begin_before nl "{" inl RuleBodyMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols  { foreach (member in this.RuleBodyMembers) member.CollectGlobalSymbols(owner); }
        override MakeContext           = FoldThrough(this.RuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation       = MakeLastLocation(this, OpenBrace);
        override TypeSyntaxMappings    = foreach (x in this.RuleBodyMembers) x.TypeSyntaxMappings();
        override Typing                = foreach (x in this.RuleBodyMembers) x.Typing();
      }
  }

  syntax PrecedenceName
  {
    MakeContext(parent : Context, owner : IPrecedenceSymbolOwner, symbol : PrecedenceSymbol, order : PrecedenceOrderList) : Context;
    GetName() : Nitra.Model.Identifier;
    GetBindingPowerInfo(context : Context, isStrong : bool) : BindingPowerInfo;

    | Zero = "0" as Zero
      {
        override MakeContext
        {
          _ = owner;
          _ = symbol;
          when (order is Some((errorLoc, _)))
            parent.Error(errorLoc, "Order not allowed for zero precedence.");
          PrecedenceZeroContext(parent)
        }
        override GetName = Nitra.Model.Identifier(Location(this.Location.Source, this.Zero), "0");
        override GetBindingPowerInfo { _ = context; BindingPowerInfo(PrecedenceReference.Zero(), isStrong); }
      }
    | Identifier
      {
        override MakeContext
        {
          //TODO: добавить проверку порядка контекстов
          if (symbol != null)
            PrecedenceNamedContext(parent, owner, symbol, GetName(), order);
          else
            parent
        }
        override GetName = this.Identifier.Identifier();
        override GetBindingPowerInfo = BindingPowerInfo(PrecedenceReference.Name(context.Bind.[PrecedenceSymbol](this.Identifier)), isStrong);
      }
  }

  syntax RuleBodyMember
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context;
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(owner);
        override MakeContext          = RegexRule.MakeContext(parent);
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(owner);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(owner);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | ExtensionRule = "|" sm RuleAttributes (Name "=")? RuleExpression RightAssociativeOpt=("right-associative")? RuleBody?
      {
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtensionRuleSymbol = ParsedExtensionRuleSymbol(this, owner);
        override CollectGlobalSymbols
        {
          match (owner : object)
          {
            | ExtensibleRuleSymbol
            | ExtendSyntaxSymbol => ()
            | _ => owner.Node.Project.Error(this, "Extension rule declaration is not allowed here.")
          }
          def symbol = MakeSymbol(owner);
          _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
          when (RuleBodyOpt.HasValue)
            RuleBodyOpt.Value.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context = RuleDeclarationSiteContext(parent, Symbol);
          _ = RuleAttributes.MakeContext(context);
          _ = MakeRuleTypingContext(context);
          parent
        }
        [Cached] private MakeRuleTypingContext(parent : Context) : Context
        {
          if (RuleBodyOpt.HasValue)
            RuleBodyOpt.Value.MakeContext(parent)
          else
            parent
        }
        [Cached] private MakeBaseRuleRef() : ExtensibleRuleRef
        {
          match (this.Symbol.DeclarationSite)
          {
            | s is ExtensibleRuleSymbol => SymbolRef.Some(s.FirstLocation, false, s)
            | s is ExtendSyntaxSymbol   => s.Extend
            | owner                     => SymbolRef.None(owner.FirstLocation, false)
          }
        }
        [Cached] private MakeTypedRule(precedenceContext : PrecedenceContext) : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, RuleTypingContext, RuleExpression.Typing(BaseRuleRef, PrecedenceInfo(precedenceContext, RightAssociativeOpt.HasValue, false), None(), RuleTypingContext, this.Symbol.Options));
        override TypeSyntaxMappings    = when (this.RuleBodyOpt.HasValue) this.RuleBodyOpt.Value.TypeSyntaxMappings();
        override Typing
        {
          def baseRuleRef = MakeBaseRuleRef();
          _ = MakeTypedRule(RuleTypingContext.TryGetContext.[PrecedenceContext]());

          when (this.Symbol.Options.OperatorInfo == OperatorInfo.None && baseRuleRef.IsSome)
            TryInferOperatorType(this.Symbol);
          when (this.RuleBodyOpt.HasValue)
            this.RuleBodyOpt.Value.Typing();
        }
      }
    | Precedence = "precedence" sm PrecedenceName Order = (sm "order" sm (Name; sm "<" sm){2,})? ":"
      {
        [Cached] private MakeOwner(owner : IRuleDeclarationSite) : IPrecedenceSymbolOwner
        {
          match (owner)
          {
            | owner is IPrecedenceSymbolOwner => owner
            | _                               => owner.Node.Project.Error(this, "Precedence declaration is not allowed here."); null
          }
        }
        [Cached] private MakeSymbol() : PrecedenceSymbol
        {
          PrecedenceSymbol.GetPrecedenceSymbol(Owner, this.PrecedenceName.GetName())
        }
        override CollectGlobalSymbols
        {
          _ = MakeOwner(owner);
          _ = MakeSymbol();
        }
        override MakeContext
        {
          def order =
            if (Order.HasValue)
              Some(Order.Location, Order.Value.Item2.Item1.Identifiers())
            else
              None();

          PrecedenceName.MakeContext(parent, Owner, Symbol, order);
        }
        override Typing
        {
          when (Context is PrecedenceContext as context)
            context.Typing();
        }
      }
    | MapSyntax = "map" ParametersOpt=MapSyntaxParameters? sm AstName=NitraType MapSyntaxBody
      {
        [Cached] private MakeOwner(owner : IRuleDeclarationSite) : IRuleDeclarationSite = owner;
        override CollectGlobalSymbols { _ = MakeOwner(owner) }
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeParameters() : list[SyntaxMappingParameterSymbol] = if (this.ParametersOpt.HasValue) this.ParametersOpt.Value.Typing(this.Context) else [];
        [Cached] private MakeReturnType() : AstType = TypingUtils.NTypeToAstTypeWithMessage(this.AstName, this.Context);
        [Cached] private MakeSymbol() : SymbolRef[SyntaxMappingSymbol]
        {
          if (this.Owner : object is SyntaxRuleSymbol as ruleSymbol)
          {
            def symbol = ParsedInplaceSyntaxMappingSymbol(this, ruleSymbol);
            ruleSymbol.AddSyntaxMapping(symbol);
            SymbolRef.Some(this.Location, false, symbol)
          }
          else
          {
            this.Context.Error(this, "AST mapping is not allowed here.");
            SymbolRef.None(this.Location, false)
          }
        }
        [Cached] private MakeExpr() : SyntaxMappingExpr
        {
          if (this.Symbol is SymbolRef.Some(syntaxMapping))
            this.MapSyntaxBody.TypeSyntaxMappings(syntaxMapping)
          else
            null
        }
        override Typing
        {
          _ = MakeSymbol();
          (this.Context :> MapSyntaxContext).Initialize(MakeParameters(), MakeReturnType());
        }
        override TypeSyntaxMappings
        {
          _ = MakeExpr();
        }
      }
    | RuleMethod = RuleMethodAttributes RuleMethodPrivate? Name sm "(" (RuleMethodParam; "," sm)* ")" sm ":" sm Type=NitraType RuleMethodBody
      {
        token RuleMethodPrivate = "private" sm;

        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.DefinitionSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | ruleSymbol is SyntaxRuleSymbol =>
              if (RuleMethodPrivateOpt.HasValue)
              {
                when (RuleMethodBody.IsEmpty())
                  compilerMessages.Error(this, "A private rule method must have a body.");
                unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensionRuleSymbol)
                  compilerMessages.Error(this, "A private rule method can be declared only in simple rules and extension rules.");
                RuleMethod.ParsedDefPrivateSymbol(this)
              }
              else if (RuleMethodBody.IsEmpty())
              {
                unless (ruleSymbol is ExtensibleRuleSymbol)
                  compilerMessages.Error(this, "An abstract rule method must be defined in an extension point rule only.");
                RuleMethod.ParsedAbstractSymbol(this)
              }
              else
              {
                unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensibleRuleSymbol)
                  compilerMessages.Error(this, "A public rule method must be defined in an extension point rule or a simple rule only.");
                RuleMethod.ParsedDefSymbol(this)
              }

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeSignature() : RuleMethod.RuleMethodSignature
        {
          def context    = this.Context;
          def parameters = this.RuleMethodParams.Item1.MapToList(_.TypeForRuleMethod(context));
          def (type, _)  = this.Type.Typing(context);
          RuleMethod.RuleMethodSignature(this.Location, parameters, type);
        }
        [Cached] private MakeBody()     : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        [Cached] private MakeIsCached() : bool                      = RuleMethodAttributes.IsCached();
        [Cached] private MakeAstType()  : AstType                   = TypingUtils.NTypeToAstType(this.Signature.Type, this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeSignature();
            _ = MakeBody();
            _ = MakeIsCached();
            _ = MakeAstType();
          }
        }
      }
    | RuleMethodOverride = RuleMethodAttributes "override"     sm  Name RuleMethodBody
      {
        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.DefinitionSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | _ is SyntaxRuleSymbol =>
              when (RuleMethodBody.IsEmpty())
                compilerMessages.Error(this, "An overriding rule method must have a body.");
              RuleMethod.ParsedOverrideSymbol(this)

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeBaseRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtensionRuleSymbol(BaseRule = SymbolRef.Some(baseRuleSymbol)) =>
              match (baseRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
              {
                | [RuleMethod.DefSymbol      as baseRuleMethodSymbol]
                | [RuleMethod.AbstractSymbol as baseRuleMethodSymbol] =>
                  SymbolRef.Some(Name.Location, false, baseRuleMethodSymbol)

                | [_] =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"Cannot override '$name' rule method."); //TODO: rewrite error message!
                  SymbolRef.None(Name.Location, false)

                | _ =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"No '$name' rule method to override.");
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              compilerMessages.Error(this, "An rule method can be overridden only in extending rules.");
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeBaseRuleMethod(this.Context);
            _ = MakeBody();
          }
        }
      }
    | RuleMethodMissing = RuleMethodAttributes "missing"        sm  Name RuleMethodBody
      {
        override MakeContext = parent;
        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : RuleMethod.RuleMethodMissingValueSymbol
        {
          def compilerMessages = owner.Node.Project;
          match (owner)
          {
            | _ is SyntaxRuleSymbol =>
              when (RuleMethodBody.IsEmpty())
                compilerMessages.Error(this, "A 'missing' handler must have a body.");
              RuleMethod.ParsedRuleMethodMissingValueSymbol(this);

            | _ => compilerMessages.Error(this, "Rule method is not allowed here."); null
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          when (symbol != null)
            _ = owner.Node.AddAndReport(symbol, this.Location);
        }
        [Cached] private MakeHandlingRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtensibleRuleSymbol as targetRuleSymbol
            | SimpleRuleSymbol     as targetRuleSymbol =>
              match (targetRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
              {
                | [ruleMethodSymbol] => SymbolRef.Some(Name.Location, false, ruleMethodSymbol)
                | _ =>
                  def name = Name.Value();
                  compilerMessages.Error(this, $"No '$name' rule method to handle 'missing'.");
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              compilerMessages.Error(this, "A 'missing' handler for a rule method can be defined in simple and extensible rules.");
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : RuleMethod.RuleMethodBody = this.RuleMethodBody.MakeBody(this.Context);
        override Typing
        {
          when (this.Symbol != null)
          {
            _ = MakeHandlingRuleMethod(this.Context);
            _ = MakeBody();
          }
        }
      }
  }

  syntax RuleMethodParam = Name sm ":" sm Type=NitraType
  {
    TypeForRuleMethod(context : Context) : RuleMethod.RuleMethodParameter = RuleMethod.RuleMethodParameter(this.Location, this.Name.Identifier(), this.Type.Typing(context)[0]);
    TypeForMapSyntax(context : Context)  : SyntaxMappingParameterSymbol   = ChemicalSyntaxMappingParameterSymbol(this.Name.Identifier(), TypingUtils.NTypeToAstTypeWithMessage(this.Type, context));
  }

  syntax RuleMethodAttributes = RuleMethodAttributeList*
  {
    syntax RuleMethodAttribute
    {
      IsCached() : bool;

      | Cached = AttributeName="Cached" { override IsCached = true; }
    }

    syntax RuleMethodAttributeList = "[" (RuleMethodAttribute; ",")+ "]" nl
    {
      IsCached() : bool
      {
        foreach(x when x.IsCached() in RuleMethodAttributes.Item1)
          return true;
        false
      }
    }

    IsCached() : bool
    {
      foreach(x when x.IsCached() in RuleMethodAttributeLists)
        return true;
      false
    }
  }

  syntax RuleMethodBody
  {
    BodyLocation() : Nitra.Location;
    IsEmpty() : bool;
    MakeBody(context : Context) : RuleMethod.RuleMethodBody = RuleMethod.RuleMethodBody(this.BodyLocation(), NemerleParser.Parse(this, context));

    | Block
      {
        override BodyLocation = Block.Location;
        override IsEmpty = false;
      }
    | Expression = sm "=" sm Expression ";" nl
      {
        override BodyLocation = Expression.Location;
        override IsEmpty = false;
      }
    | Empty = ";" nl
      {
        override BodyLocation = this.Location.FromStart();
        override IsEmpty = true;
      }
  }

  syntax Block = outline_hiden outline_begin_before nl "{" inl (Expression; ";" nl)* ";"* nl d "}" outline_end_before nl;

  syntax Expression = Body=ContentOrText+
  {
    syntax Content
    {
      | Block;
      | IgnoreToken+;
      | CharLiteral;
      | StringLiteral;
      | Parentheses = "(" Expression? ")";
      | "fold" sm Identifier "(" Expression ";" (Expression; ";"sm)+ ")";
    }

    syntax ContentOrText
    {
      | Content;
      | Text = (!";" !")" !"}" !Content Any)+;
    }
  }

  syntax Range
  {
    RangeSet(inCharSet : RangeSet, _compilationMessages : ICompilerMessages) : RangeSet;

    | SingleChar = CharLiteral
      {
        override RangeSet = inCharSet.AddSingleCharRange(CharLiteral.Value());
      }
    | CharRange       = CharLiteral ".." CharLiteral
      {
        override RangeSet = inCharSet.AddRange(CharLiteral1.Value(), CharLiteral2.Value());
      }
    | UnicodeRange    = Name
      {
        override RangeSet
        {
          def nameText = Name.Value();
          if (UnicodeCategoryTable.StrToUnicodeCategory(nameText) is Some(cat))
            inCharSet.AddRange(cat)
          else
          {
            _compilationMessages.Error(this, $"Invalid unicode category '$nameText'.");
            inCharSet
          }
        }
      }
  }

  syntax RepeatQuantifier
  {
    Bounds() : int * option[int];

    | ZeroOrMany = "*"                                { override Bounds = (0,               None());                }
    | OneOrMany  = "+"                                { override Bounds = (1,               None());                }
    | UpperBound = "{" sm        "," sm Number sm "}" { override Bounds = (0,               Some(Number.Value()));  }
    | LowerBound = "{" sm Number ","           sm "}" { override Bounds = (Number.Value(),  None());                }
    | FullBounds = "{" sm Number "," sm Number sm "}" { override Bounds = (Number1.Value(), Some(Number2.Value())); }
    | Exact      = "{" sm Number               sm "}" { override Bounds { def x = Number.Value(); (x, Some(x)); }   }
  }

  alias Separator  = RegexExpression;

  syntax RegexExpression
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] Typing() : RegularRule;

    precedence Choice:
    | Choice                  = LeftRule=RegexExpression ^ Choice sm RightRules=("|" RegexExpression ^ Choice)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, (t, c) => t.Item2.MakeContext(c));
          context2
        }
        override Typing = RegularRule.Choice(Location, LeftRule.Typing() :: RightRules.Map(r => r.Item2.Typing()));
      }

    precedence Sequence:
    | Sequence                = LeftRule=RegexExpression ^ Sequence sm RightRules=(RegexExpression ^ Sequence)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, _.MakeContext(_));
          context2
        }
        override Typing = RegularRule.Sequence(Location, LeftRule.Typing() :: RightRules.Map(_.Typing()));
      }

    precedence Subtract:
    | Subtract                = Rule1 = RegexExpression "-" Rule2 = RegexExpression
      {
        override MakeContext = Rule2.MakeContext(Rule1.MakeContext(parent));
        override Typing = RegularRule.Subtract(Location, this.Rule1.Typing(), this.Rule2.Typing());
      }

    precedence Invert:
    | Invert                  = "~" RegexExpression
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Invert(Location, this.RegexExpression.Typing());
      }

    precedence RepeatModifier:
    | Optional                = RegexExpression "?"
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 0, Some(1), this.RegexExpression.Typing());
      }
    | Repeat              = RegexExpression RepeatQuantifier
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.Repeat(Location, lower, upper, this.RegexExpression.Typing());
        }
      }

    precedence 0:
    | Char                    = CharLiteral
      {
        override Typing = RegularRule.Chars(Location, [RangeSet().AddSingleCharRange(CharLiteral.Value())]);
      }
    | String                  = StringLiteral
      {
        override Typing = RegularRule.Chars(Location, RangeSet.MakeString(StringLiteral.Value()));
      }
    | Call                    = QualifiedName
      {
        override Typing
        {
          def sym = this.Context.Bind.[RuleSymbol](QualifiedName);
          match (sym)
          {
            | SymbolRef.Some(_ is RegularRuleSymbol) | SymbolRef.Some(_ is RuleParameterSymbol) => ()
            | SymbolRef.Some => this.Context.Error(QualifiedName, $"The '$QualifiedName' must be regex or rule parameter.");
            | _ => ()
          }
          RegularRule.Call(Location, sym);
        }
      }
    | Rounds                  = "(" RegexExpression ")"
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegexExpression.Typing();
      }
    | Range                   = "[" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, [FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))]);
        }
      }
    | InvertedRange           = "[" "^" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, InvertRange(FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))));
        }
      }
    | RepeatWithSeparator = "(" RegexExpression ";"sm Separator ")" RepeatQuantifier
      {
        override MakeContext  = parent |> RegexExpression.MakeContext |> Separator.MakeContext;
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.RepeatWithSeparator(Location, lower, upper, RegexExpression.Typing(), Separator.Typing());
        }
      }
  }

  alias Separator   = RuleExpression;

  syntax RuleExpression
  {
    Typing(_baseRule : option[ExtensibleRuleSymbol], _precedenceInfo : PrecedenceInfo, _fieldName : option[string], context : Context, _options : RuleDefinitionOptions) : Nitra.Model.Rule;
    InferName() : string = "";

    precedence Sequence:
    | Sequence                        = LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
      {
        override Typing = TypeSequence(_baseRule, _precedenceInfo, _fieldName, context, _options, LeftRule, RightRules, this);
        override InferName = LeftRule.InferName();
      }

    precedence FieldName2:
    | FieldName2                      = Name sm "=" sm RuleExpression ^ FieldName2
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }

    precedence FieldName1:
    | FieldName1                      = RuleExpression ^ FieldName1 sm "as" sm Name
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }

    precedence Predicate:
    | Not                             = "!" RuleExpression ^ Predicate
      {
        override Typing
        {
          def rule = this.RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          Rule.Not(this.Location, RuleType.Void(), "", rule);
        }
      }
    | And                             = "&" RuleExpression ^ Predicate
      {
        override Typing = Rule.And(this.Location, RuleType.Void(), "", RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options));
      }

    precedence RepeatModifier:
    | Optional                        = RuleExpression "?"
      {
        override Typing
        {
          def rule  = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def type  = EvaluateOptionRuleType(rule);
          Rule.Repeat(this.Location, type, _fieldName ?? (rule.FieldName + "Opt"), 0, Some(1), rule);
        }
        override InferName = RuleExpression.InferName() + "Opt";
      }
    | Repeat                      = RuleExpression RepeatQuantifier
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def type           = EvaluateListRuleType(rule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          Rule.Repeat(this.Location, type, MakePlural(_fieldName, rule, context), lower, upper, rule);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }

    precedence 0:
    | Char                            = CharLiteral
      {
        override Typing = StringRuleTyping(CharLiteral.Location, CharLiteral.Value().ToString(), _fieldName, context);
        override InferName = CharLiteral.Value().ToString();
      }
    | String                          = StringLiteral
      {
        override Typing = StringRuleTyping(StringLiteral.Location, StringLiteral.Value().ToString(), _fieldName, context);
        override InferName = StringLiteral.Value().ToString();
      }
    | Rounds                          = "(" RuleExpression ")"
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedenceInfo, _fieldName, context, _options);
        override InferName = RuleExpression.InferName();
      }
    | Call                            = QualifiedName RuleAruments = RuleAruments? BindingPower=(sm "^" sm "+"? PrecedenceName)?
      {
        syntax RuleAruments = "<" (RuleArument; ",")+ ">"
        {
          syntax RuleArument
          {
            | Reference
            //| RegexExpression
          }
        }
        override Typing = TypeCall(_baseRule, _precedenceInfo, _fieldName, context, _options, QualifiedName, RuleAruments, BindingPower);
        override InferName = QualifiedName.LastIdentifier().Value;
      }
    | RepeatWithSeparator         = "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), _precedenceInfo, None(), context, _options);
          def sepRule        = Separator.Typing(None(), PrecedenceInfo.None, None(), context, _options);
          def type           = EvaluateListWithSeparatorRuleType(rule, sepRule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          def isHanging      = HangingOpt.HasValue;
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), lower, upper, rule, sepRule, isHanging);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }
  } // extend syntax RuleExpression
} // syntax module
