using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;
// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol  = Nitra.Runtime.Binding.Symbol2;
using ISymbol = Nitra.Runtime.Binding.ISymbol2;

namespace Nitra.Runtime.Binding
{
  public module SymbolUtils
  {
    public static ReportError(symbol : ISymbol) : void
    {
      match (symbol)
      {
        | UnresolvedSymbol as us => AstContext.CompilerMessages.Error(us.Reference, $<#Unbound name '$(us.Name)'.#>);
        | AmbiguousSymbol as sym =>
          def e = sym.AllDeclarations.GetEnumerator();
          if (e.MoveNext())
          {
            def firstName = e.Current.Name;
            using (err = AstContext.CompilerMessages.RootError(firstName, $<#Symbol '$(firstName)' is ambiguous.#>))
            {
              while (e.MoveNext())
              {
                def otherName = e.Current.Name;
                err.Hint(otherName, <#Declaration#>);
              }
            }
          }
          else
            assert(false, "Ambiguous symbol without declarations detected!");

        | _ => ()
      }
    }

    public static ReportError(reference : IAst, symbol : ISymbol) : void
    {
      match (symbol)
      {
        | UnresolvedSymbol => AstContext.CompilerMessages.Error(reference, $<#Unbound name '$reference'.#>);
        | AmbiguousSymbol as sym =>
          using (err = AstContext.CompilerMessages.RootError(reference, $<#Symbol '$reference' is ambiguous.#>))
            foreach (a in sym.Ambiguous with i)
              foreach (d when d.Span != reference.Span && d.File : object != reference.File in a.Declarations)
                err.Hint(d, $<#Declaration $i#>);

        | _ => ()
      }
    }

    public static TryResolve[T](reference : Reference, symbol : T, algorithm : Func[IAmbiguousSymbol, Seq[ISymbol]]) : ISymbol
      where T: IAmbiguousSymbol
    {
      assert(!symbol.IsResolved, "You can do overload resolution only once.");

      def results = algorithm(symbol).ToArray();
      match (results.Length)
      {
        | 0 => UnresolvedSymbol(reference)
        | 1 =>
          def resolved = results[0];
          symbol.SetResolutionResult(results[0]);
          resolved

        | _ =>
          def resultList = results.NToList();
          symbol.SetResolutionResultList(resultList);
          AmbiguousSymbol(resultList)
      }
    }

    public static GetSymbolName[TDeclaration](isNameValid : bool, declarations : list[TDeclaration]) : string
      where TDeclaration : Declaration
    {
      if (isNameValid)
        declarations.Head.Name.Text
      else
        "<invalid name>"
    }

    public static AddDeclaration[TDeclaration](newDeclaration : TDeclaration, isNameValid : ref bool, declarations : ref list[TDeclaration]) : void
      where TDeclaration : Declaration
    {
      assert(newDeclaration : object != null);

      match (declarations)
      {
        | [] => isNameValid = true;
        | f :: _ when isNameValid => isNameValid = f.Name.Id == newDeclaration.Name.Id
        | _ => ()
      }

      declarations ::= newDeclaration;
    }
  }
}
