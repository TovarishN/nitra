using Nitra;
using Nitra.Declarations;
using Nitra.LanguageCompiler.Utils;
using Nitra.Runtime.Binding;

using System.Collections.Generic;

using Color = System.Windows.Media.Color;

namespace Nitra
{
  ast QualifiedIdentifier
  {
    Parts : Identifier*;
  }

  declaration Language
  {
    Properties.StylesIn     = Dictionary();
    Properties.StyleScopeIn = Properties.StylesOut;

    Properties : LanguageProperty*;

    decompose Properties
    {
      FileExtensions            : LanguageProperty.FileExtension+;
      SpanClassesInlines        : LanguageProperty.SpanClassDefinitionInline*;
      SpanClassDefinitionStyles : LanguageProperty.SpanClassDefinitionStyle*;
      StartSyntaxModule         : LanguageProperty.StartSyntaxModule;
      AdditionalSyntaxModules   : LanguageProperty.SyntaxModule*;
      Styles                    : LanguageProperty.Style*;
      Company                   : LanguageProperty.Company;
      Description               : LanguageProperty.Description;
      Authors                   : LanguageProperty.Authors;   
      Copyright                 : LanguageProperty.Copyright;
      LicenseUrl                : LanguageProperty.LicenseUrl;
      RequireLicenseAcceptance  : LanguageProperty.RequireLicenseAcceptance?;
    }
  }

  abstract ast Format
  {
    | ForegroundColor { Color : Color; }
  }

  map syntax LangSpec.Format -> Format
  {
    | ForegroundColor { Color = ParsedValue(Color.Span, Color.Value(AstContext.CompilerMessages)); }
  }

  abstract ast LanguageProperty
  {
    inout Styles     : Dictionary<int, LanguageProperty.Style>;
    inout StyleScope : Dictionary<int, LanguageProperty.Style>;

    | SpanClassDefinitionInline
      {
        Name    : Name;
        Formats : Format*;

        decompose Formats
        {
          ForegroundColor : Format.ForegroundColor;
        }
      }

    | SpanClassDefinitionStyle
      {
        out StyleDef : LanguageProperty.Style = Lookup(StyleScopeIn, StyleRef, AstContext.CompilerMessages);

        Name     : Name;
        StyleRef : Reference;
      }

    | SyntaxModule
      {
        Module  : QualifiedIdentifier;
      }

    | StartSyntaxModule
      {
        Module    : QualifiedIdentifier;
        StartRule : QualifiedIdentifier;
      }

    | FileExtension
      {
        Ext : string;
      }

    | Company
      {
        Name  : string;
      }

    | Description { Text : string; }
    | Authors     { Text : string; }
    | Copyright   { Text : string; }
    | LicenseUrl  { Text : string; }
    | RequireLicenseAcceptance { }
    | Style
      {
        StylesOut = Add(StylesIn, this, AstContext.CompilerMessages);

        Name    : Name;
        Formats : Format*;

        decompose Formats
        {
          ForegroundColor : Format.ForegroundColor;
        }
      }
  }

  ast Identifier { Text : string; }

  map syntax LangSpec.Identifier -> Identifier { Text = ParsedValue(Span, GetText()); }

  map syntax LangSpec.QualifiedIdentifier -> QualifiedIdentifier
  {
    Parts.Item1 -> Parts;
  }

  map syntax LangSpec.Language -> Language
  {
    Name       -> Name;
    Properties -> Properties;
  }

  map syntax LangSpec.LanguageProperty -> LanguageProperty
  {
    | Style                     { Name -> Name; Formats -> Formats; }
    | SpanClassDefinitionStyle  { Name -> Name; Style   -> StyleRef; }
    | SpanClassDefinitionInline { Name -> Name; Formats -> Formats; }
    | Company                   { Name = ParsedValue(Name, GetText(Name)); }
    | Description               { Text = ParsedValue(Text, GetText(Text)); }
    | Authors                   { Text = ParsedValue(Text, GetText(Text)); }
    | Copyright                 { Text = ParsedValue(Text, GetText(Text)); }
    | LicenseUrl                { Text = ParsedValue(Text, GetText(Text)); }
    | RequireLicenseAcceptance  { }
    | FileExtension             { Ext = ParsedValue(Ext, GetText(Ext)); }
    | SyntaxModule(_, _, moduleName, None, _)                    -> SyntaxModule      { moduleName -> Module; }
    | SyntaxModule(_, _, moduleName, Some((_, _, startRule)), _) -> StartSyntaxModule { moduleName -> Module; startRule -> StartRule; }
  }
}
