using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace Tdl
{
  module TdlUtils
  {
    public MakeDeployments(deploymentRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[DeploymentSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (deploymentRef in deploymentRefs)
      {
        def r = deploymentRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeScenarios(scenariosRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ScenarioSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (scenariosRef in scenariosRefs)
      {
        def r = scenariosRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAggregateParametersScope(deployments : ImmutableArray[DeploymentSymbol]) : Scope
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      CollectDeployments(visited, ref builder, deployments);
      builder.ToScope()
    }

    private CollectDeployments(visited : HashSet[int], builder : ref UnionScopeBuilder, deployments : ImmutableArray[DeploymentSymbol]) : void
    {
      foreach (deployment in deployments)
      {
        unless (visited.Add(deployment.Id))
          return;

        match (deployment)
        {
          | s is Deployment.ScriptSymbol => UnionScopeBuilder.Add(s.ParameterScope, ref builder);
          | s is Deployment.SetSymbol => CollectDeployments(visited, ref builder, s.Deployments);
          | _ => ()
        }
      }
    }

    public MakeAggregateParametersScope(scenarios : ImmutableArray[ScenarioSymbol]) : Scope
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      CollectScenarios(visited, ref builder, scenarios);
      builder.ToScope()
    }

    private CollectScenarios(visited : HashSet[int], builder : ref UnionScopeBuilder, scenarios : ImmutableArray[ScenarioSymbol]) : void
    {
      foreach (deployment in scenarios)
      {
        unless (visited.Add(deployment.Id))
          return;

        match (deployment)
        {
          | s is Scenario.DefSymbol => UnionScopeBuilder.Add(s.Deployment.AggregateParametersScope, ref builder);
          | s is Scenario.SetSymbol => CollectScenarios(visited, ref builder, s.Scenarios);
          | _ => ()
        }
      }
    }

    public MakeExpected(intLiteral : IntLiteral) : ParsedValue[int]
    {
      intLiteral.Value
    }
    
    public ConvertStringLiteral(str : CSharp.StringLiteral) : ParsedValue[string]
    {
      def builder = Text.StringBuilder();
      foreach (part in str.Parts)
      {
        | Interpolation           => ()
        | InterpolationFormated   => ()
        | InterpolatedOpenEscape  => _ = builder.Append("{");
        | InterpolatedCloseEscape => _ = builder.Append("}");
        | Error                   => ()
        | SimpleEscape            => _ = builder.Append(part.Location.GetText()); // FIXME:
        | UnicodeEscape           => _ = builder.Append(part.Location.GetText()); // FIXME:
        | HexadecimalEscape       => _ = builder.Append(part.Location.GetText()); // FIXME:
        | RegulaChars             => _ = builder.Append(part.Location.GetText());
        | VerbatimEscape          => _ = builder.Append(part.Location.GetText()); // FIXME:
        | _                       => ()
      }

      ParsedValue(str.Location.Span, builder.ToString())
    }

    private ConvertDefExpr(expr : DefExpr) : Expr
    {
      match (expr)
      {
        | x is DefExpr.String                    => Expr.String(ConvertStringLiteral(x.Value).Value)
        | _ is DefExpr.True                      => Expr.True()
        | _ is DefExpr.False                     => Expr.False()
        | x is DefExpr.RealLiteral               => Expr.Integerl(int.Parse(x.Location.GetText()))
        | x is DefExpr.HexadecimalIntegerLiteral => Expr.Integerl(int.Parse(x.Location.GetText()))
        | x is DefExpr.Reference                 => Expr.Reference(x.Location.GetText())
        | x with loc = x.Location                => Expr.Error(Utils.Location(loc.Source.File.FullName, loc.StartPos, loc.EndPos))
      }
    }
    
    public MakeDefinitions(definitions : Definition.IAstList) : ImmutableArray[Def]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition in definitions)
      {
        builder.Add(Def(definition.Reference.Text, ConvertDefExpr(definition.Expr)));
      }
      builder.MoveToImmutable()
    }

    public Resolve(platformRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[Ref[PlatformSymbol]]
    {
      def builder = ImmutableArray.CreateBuilder(platformRefs.Length);
      foreach (platformRef in platformRefs)
        builder.Add(platformRef.Resolve());
      builder.MoveToImmutable()
    }

    public ToSymbol(it : PlatformSymbol, platforms : ImmutableArray[Ref[PlatformSymbol]]) : ImmutableArray[PlatformSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(platforms.Length);
      def visited = HashSet();
      _ = visited.Add(it);
      def loccectAllPlatforms(platforms : ImmutableArray[Ref[PlatformSymbol]])
      {
        foreach (platformRef when platformRef.IsSymbolEvaluated in platforms)
        {
          unless (visited.Add(platformRef.Symbol))
            continue;
          match (platformRef.Symbol)
          {
            | s is Platform.DefSymbol => builder.Add(s);
            | s is Platform.SetSymbol => loccectAllPlatforms(s.PlatformsRefs);
            | _ => assert(false)
          }
        }
      }

      loccectAllPlatforms(platforms);

      if (builder.Capacity == builder.Count)
        builder.MoveToImmutable()
      else
        builder.ToImmutable()
    }
  } // module
} // namespace
