using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.Internal;
using Nitra.ProjectSystem;
using Nitra.Runtime.GraphUtils;

using Microsoft.Cci;

using System;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;

using NRB = Nitra.Declarations;
using Queue = System.Collections.Generic.Queue;

namespace Nitra.BackEnd.Cci
{
  public enum ThreeColor
  {
    | White
    | Gray
    | Black
  }

  public partial class CciProject
  {
    internal class CciPlatform : IDisposable
    {
      public static NitraMetadataStreamName     = "Nitra.Metadata2";
      public static NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
      public static NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
      public static NoSpan : NSpan              = NSpan(0);

      public CciHost           : IMetadataHost { get; protected set; }
      public CancellationToken : CancellationToken { get; set; }

              _cciInternedKeyToSymbolMap        : Hashtable.[uint, TypeSymbol] =  Hashtable();
              _cciInternedKeyToGenericSymbolMap : ConcurrentDictionary.[uint, TypeSymbol] = ConcurrentDictionary();
      mutable _singleDimensionArray             : SingleDimensionArraySymbol;
      mutable _cciObject                        : INamespaceTypeDefinition;
      mutable _objectSymbol                     : TypeSymbol;
              _nitraMetadataStreamName          : IName;
      public  AliasesNamespace                  : NamespaceSymbol { get; internal set; }
      mutable _assembliesGraph                  : CciDotNetAssemblyUnit;
      mutable _assemblyToNodeMap                : Dictionary[AssemblyIdentity, CciDotNetAssemblyUnit] = Dictionary();

      /// Return Nitra Platform which encapsulate .Net platform (.Net Framework, .Net Core, ... and its version).
      public static GetPlatform(corelibRefOpt : ValueOption[LibReference]) : CciPlatform
      {
        if (corelibRefOpt is VSome(corelibRef))
          throw NotImplementedException();
        else
          CciPlatform(PeReader.DefaultHost())
      }

      private this(cciHost : IMetadataHost)
      {
        CciHost = cciHost;
        _nitraMetadataStreamName = cciHost.NameTable.GetNameFor(NitraMetadataStreamName);
      }

      public Types                : Seq[TypeSymbol]            { get { _cciInternedKeyToSymbolMap.Values } }
      public Object               : TypeSymbol                 { get { _objectSymbol } }
      public SingleDimensionArray : SingleDimensionArraySymbol { get { _singleDimensionArray } }

      public MekeAssemblyList(libs : IEnumerable[LibReference], libPath : string, addError : Action[Location, string]) : List[LibReference * CciDotNetAssemblyUnit] * List[ProjectReference]
      {
        def units = List();
        def projects       = List();

        foreach(lib in libs)
        {
          | projectRef is ProjectReference => projects.Add(projectRef);
          | name is FullNameLibReference with filePath = name.Path
          | file is FileLibReference     with filePath = file.Path =>
            this.CancellationToken.ThrowIfCancellationRequested();

            def libFilePath = Path.Combine(libPath, filePath);
            def unit = CciHost.LoadUnitFrom(libFilePath);

            assert2(unit != null);

            when (unit.Equals(Dummy.Module) || unit.Equals(Dummy.Assembly) || !(unit is IAssembly))
            {
              addError(NoLocation, "The referenced file '" + libFilePath + "' is not .Net assembly.");
              continue;
            }

            def assembly = unit :> IAssembly;
            def unit     = AddAssembly(assembly, needLoadSymbols=true);
            units.Add(lib, unit);

          | _ => throw NotImplementedException("Loading types from " + lib + " not supported yet.")
        }

        UpdateGraph(units);

        (units, projects)
      }

      UpdateGraph(units : List[LibReference * CciDotNetAssemblyUnit]) : void
      {
        def nodes = Queue();
        foreach ((_, unit) when !unit.InDependencyGraph in units)
          nodes.Enqueue(unit);

        AddAssemblyToGraph(nodes);
      }

      public abstract class GraphTopologicalSort[T]
        where T : IGraphNode[T]
      {
        public StopIfCycled : bool { get; }
        _sortedNodes : List[T];
        mutable _cycledEdges : list[T * T] = [];

        protected abstract GetColor(node : T) : ThreeColor;
        protected abstract SetColor(node : T, color : ThreeColor) : void;
        public SortedNodes : Seq[T] { get { _sortedNodes } }
        public CycledEdges : Seq[T * T] { get { _cycledEdges } }
        public IsCycled : bool { get { !_cycledEdges.IsEmpty } }

        protected this(graph : Seq[T])
        {
          this(graph, stopIfCycled = false, capacity = 0)
        }

        /// Return true if graph sorted and false if cycle is found.
        protected this(graph : Seq[T], stopIfCycled : bool, capacity : int)
        {
          StopIfCycled = stopIfCycled;
          _sortedNodes = List(capacity);

          foreach (node in graph)
          {
            def cycle = DepthFirstSearch(node);
            when (cycle)
              return;
          }
          _sortedNodes.Reverse();
        }

        /// Return flase if cycle is found.
        DepthFirstSearch(node : T) : bool
        {
          match (GetColor(node))
          {
            | ThreeColor.Gray  => true
            | ThreeColor.Black => false
            | _ =>
              SetColor(node, ThreeColor.Gray);
              foreach (connection in node.Connections)
                when (DepthFirstSearch(connection))
                {
                  _cycledEdges ::= (node, connection);
                  when (StopIfCycled)
                    return true;
                  continue;
                }

              _sortedNodes.Add(node);
              SetColor(node, ThreeColor.Black);
              false
          }
        }
      }

      [Record]
      class UnitsTopologicalSort : GraphTopologicalSort[CciDotNetAssemblyUnit]
      {
        protected override GetColor(node : CciDotNetAssemblyUnit) : ThreeColor { node.Color }
        protected override SetColor(node : CciDotNetAssemblyUnit, color : ThreeColor) : void { node.Color = color; }
      }

      public LoadAssemblies(project : Project, context : DotNetDependentPropertyEvalContext) : void
      {
        foreach (node in _assemblyToNodeMap.Values)
          node.Color = ThreeColor.White;
        def sorter = UnitsTopologicalSort([_assembliesGraph], false, _assemblyToNodeMap.Count);
        unless (sorter.IsCycled)
        {
          _ = project.CompilerMessages.RootError(NoLocation, $"Cycle is found in the '$(project.ProjectDir)' project.", -1);
          return;
        }

        foreach (node in sorter.SortedNodes with i)
          node.Order = i;

        Visualize(result);

        foreach (node when node.IsSymbolsLoaded in result)
        {
          LoadLib(node, project, context);
          assert2(node.IsSymbolsLoaded);
        }
      }

      public static ToDot(units : List[LibReference * CciDotNetAssemblyUnit], nodes : List[string], edges : List[string]) : void
      {
        foreach ((_r, node) in units)
        {
          def name(node : CciDotNetAssemblyUnit) : string { node.Assembly.Name.Value.Replace(".", "_"); }
          def label(node : CciDotNetAssemblyUnit) : string { node.Assembly.Name.Value; }
          nodes.Add($<#$(name(node)) [label="$(label(node))" color=purple shape=box]#>);
          foreach (to in node.Connections)
          {
            edges.Add($<#$(name(node)) -> $(name(to))#>);
          }
        }
      }

      public static Visualize(units : List[LibReference * CciDotNetAssemblyUnit]) : void
      {
        def nodes = List();
        def edges = List();

        ToDot(units, nodes, edges);

        def typeName = "Assemblies dependencies";
        def content = $<#
          digraph RecoveryParser
          {
            compound=true;
            label="$typeName";

            ..$(nodes; "\r\n          ")

            ..$(edges; "\r\n          ")
          }
        #>;
        DotUtils.ExecuteDot(content);
      }

      public static ToDot(units : List[CciDotNetAssemblyUnit], nodes : List[string], edges : List[string]) : void
      {
        foreach (node in units)
        {
          def name(node : CciDotNetAssemblyUnit) : string { node.Assembly.Name.Value.Replace(".", "_"); }
          def label(node : CciDotNetAssemblyUnit) : string { node.Assembly.Name.Value; }
          nodes.Add($<#$(name(node)) [label="$(label(node))\n$(node.Order)" color=purple shape=box]#>);
          foreach (to in node.Connections)
          {
            edges.Add($<#$(name(node)) -> $(name(to))#>);
          }
        }
      }

      public static Visualize(units : List[CciDotNetAssemblyUnit]) : void
      {
        def nodes = List();
        def edges = List();

        ToDot(units, nodes, edges);

        def typeName = "Assemblies dependencies";
        def content = $<#
          digraph RecoveryParser
          {
            compound=true;
            label="$typeName";

            ..$(nodes; "\r\n          ")

            ..$(edges; "\r\n          ")
          }
        #>;
        DotUtils.ExecuteDot(content);
      }

      AddAssembly(assembly : IAssembly, needLoadSymbols : bool) : CciDotNetAssemblyUnit
      {
        mutable node;
        when (_assemblyToNodeMap.TryGetValue(assembly.AssemblyIdentity, out node))
        {
          when (!node.NeedLoadSymbols && needLoadSymbols)
            node.NeedLoadSymbols = true;
          return node;
        }

        node = CciDotNetAssemblyUnit(assembly, needLoadSymbols);
        _assemblyToNodeMap.Add(assembly.AssemblyIdentity, node);

        when (assembly.AssemblyIdentity.Equals(CciHost.CoreAssemblySymbolicIdentity))
        {
          _assembliesGraph = node;
          node.InDependencyGraph = true;
        }

        node
      }

      AddAssemblyToGraph(nodes : Queue[CciDotNetAssemblyUnit]) : void
      {
        while (nodes.Count > 0)
        {
          def node = nodes.Dequeue();

          when (node.InDependencyGraph)
            continue;

          def assembly = node.Assembly;

          foreach (r in assembly.AssemblyReferences)
          {
            mutable subNode;
            unless (_assemblyToNodeMap.TryGetValue(r.AssemblyIdentity, out subNode))
            {
              continue;
              //subNode = AddAssembly(r.ResolvedAssembly, false);
              //nodes.Enqueue(subNode);
            }

            subNode.AddConnection(node);
          }
          node.InDependencyGraph = true;
        }
      }

      //[Memoize]
      static IsDependsOn(visited : HashSet[IAssemblyReference], a : IAssembly, b : IAssemblyReference) : bool
      {
        unless (visited.Add(a))
          return false;

        foreach (r in a.AssemblyReferences)
        {
          when (visited.Contains(r))
            continue;

          when (UnitHelper.AssembliesAreEquivalent(r, b))
            return true;

          when (IsDependsOn(visited, r.ResolvedAssembly, b))
            return true;
        }

        false
      }

      static CompareAssemblies(a : IAssembly, b : IAssembly) : int
      {
        def visited = HashSet();

        if (IsDependsOn(visited, a, b))
          -1
        else if (IsDependsOn(visited, b, a))
          1
        else
          0
      }

      static LoadNamespace(strName : string, cciNs : INamespaceDefinition, declaredIn : NamespaceSymbol, context : DotNetDependentPropertyEvalContext) : NamespaceSymbol
      {
        def name   = NRB.Name(NoLocation, strName); // TODO: ns.Name.UniqueKey
        def symbol = ExternalNamespaceDeclaration(name, cciNs).DefineSymbol(declaredIn.MemberTable);
        unless (symbol.IsDeclaredInEvaluated)
          symbol.DeclaredIn = declaredIn;
        symbol.EvalProperties(context);
        symbol
      }

      static LoadNamespace(cciNs : INamespaceDefinition, declaredIn : NamespaceSymbol, context : DotNetDependentPropertyEvalContext) : NamespaceSymbol
      {
        LoadNamespace(cciNs.Name.Value, cciNs, declaredIn, context)
      }

      public LoadLib(unit : CciDotNetAssemblyUnit, project : Project, context : DotNetDependentPropertyEvalContext) : void
      {
        def loadDotNetSymbols(asm : IAssembly, context : DotNetDependentPropertyEvalContext, loadedTypeSymbols : List[DeclarationSymbol]) : NamespaceSymbol
        {
          this.CancellationToken.ThrowIfCancellationRequested();

          def rootNamespace = NamespaceSymbol();
          rootNamespace.DeclaredIn  = null;
          rootNamespace.FullName    = "";
          rootNamespace.EvalProperties(context);

          def ignoreName(name : string) : bool
          {
            foreach (ch when ch == '<' || ch == '?' in name)
              return true;
            false
          }
          def initTypeSymbol(typeSymbol : DeclaredTypeSymbol, type : ITypeDefinition) : void
          {
            loadedTypeSymbols.Add(typeSymbol);
            def cciInternedKeyToSymbolMap = _cciInternedKeyToSymbolMap;
            cciInternedKeyToSymbolMap[type.InternedKey] = typeSymbol;

            when (typeSymbol is GenericTypeSymbol as genericSymbol)
              MakeTypeParameters(context, genericSymbol, type);

            def modifierHost = typeSymbol;
            def flags = ModifierSet(context);
            mutable modifiers;
            when (type.IsAbstract)
              modifiers |= Modifiers.Abstract;
            when (type.IsSealed)
              modifiers |= Modifiers.Sealed;
            when (type.IsStatic)
              modifiers |= Modifiers.Static;

            // Modifiers
            match (type)
            {
              | INamespaceTypeDefinition as nsType =>
                when (nsType.IsPublic)
                  modifiers |= Modifiers.Public;

              | INestedTypeDefinition as nsType => modifiers |= MakeModifiers(nsType.Visibility);
              | _ => ()
            }

            flags.Add(modifiers);
            modifierHost.Flags = flags;

            when ((typeSymbol : DeclarationSymbol)  is CustomAttributeHostDeclarationSymbol as attrHost)
              attrHost.CustomAttributes = LazyAttributeList(type, this, context);

            typeSymbol.EvalProperties(context);

            when (typeSymbol is GenericContainerTypeSymbol as genericContainerTypeSymbol)
            {
              def nestedTypes = LightList();
              foreach (cciNestedType in type.NestedTypes)
              {
                def visibility = cciNestedType.Visibility;
                when (visibility != TypeMemberVisibility.Private && visibility != TypeMemberVisibility.Assembly)
                  nestedTypes.Add(loadNestedType(cciNestedType, genericContainerTypeSymbol));
              }

              genericContainerTypeSymbol.NestedTypes = nestedTypes.ToArray();
            }
          }
          and loadNestedType(type : INestedTypeDefinition, declaredIn : GenericContainerTypeSymbol) : NestedTypeSymbol
          {
            def name = Name(NoLocation, type.Name.Value); // TODO: type.Name.UniqueKey
            def symbol : NestedTypeSymbol  =
                     if (type.IsDelegate)  ExternalNestsdTypeDeclaration.[NestedDelegateSymbol] (name, type).DefineSymbol(declaredIn.MemberTable)
                else if (type.IsInterface) ExternalNestsdTypeDeclaration.[NestedInterfaceSymbol](name, type).DefineSymbol(declaredIn.MemberTable)
                else if (type.IsEnum)      ExternalNestsdTypeDeclaration.[NestedEnumSymbol]     (name, type).DefineSymbol(declaredIn.MemberTable)
                else if (type.IsValueType) ExternalNestsdTypeDeclaration.[NestedStructSymbol]   (name, type).DefineSymbol(declaredIn.MemberTable)
                else                       ExternalNestsdTypeDeclaration.[NestedClassSymbol]    (name, type).DefineSymbol(declaredIn.MemberTable);

            unless (symbol.IsDeclaredInEvaluated)
              symbol.DeclaredIn = declaredIn;

            initTypeSymbol(symbol, type);
            symbol
          }
          and loadNsMember(member : INamespaceMember, declaredIn : NamespaceSymbol) : void
          {
            match (member)
            {
              | type is INamespaceTypeDefinition when type.IsPublic =>
                def strName = type.Name.Value;
                when (ignoreName(strName))
                  return;

                def name = Name(NoLocation, strName); // TODO: type.Name.UniqueKey
                def symbol : TopTypeSymbol =
                         if (type.IsDelegate)  ExternalTopTypeDeclaration.[TopDelegateSymbol] (name, type).DefineSymbol(declaredIn.MemberTable)
                    else if (type.IsInterface) ExternalTopTypeDeclaration.[TopInterfaceSymbol](name, type).DefineSymbol(declaredIn.MemberTable)
                    else if (type.IsEnum)
                    {
                      def en = ExternalTopTypeDeclaration.[TopEnumSymbol]     (name, type).DefineSymbol(declaredIn.MemberTable);
                      en
                    }
                    else if (type.IsValueType) ExternalTopTypeDeclaration.[TopStructSymbol]   (name, type).DefineSymbol(declaredIn.MemberTable)
                    else                       ExternalTopTypeDeclaration.[TopClassSymbol]    (name, type).DefineSymbol(declaredIn.MemberTable);

                unless (symbol.IsDeclaredInEvaluated)
                  symbol.DeclaredIn = declaredIn;

                initTypeSymbol(symbol, type);

              | cciNs is INamespaceDefinition =>
                def strName = cciNs.Name.Value;
                when (ignoreName(strName))
                  return;
                def symbol = LoadNamespace(cciNs, declaredIn, context);
                foreach (subMember in cciNs.Members)
                  loadNsMember(subMember, symbol);

              | _ => {}
            }
          }

          foreach (subMember in asm.NamespaceRoot.Members with i)
          {
            when (i % 10 == 0)
              this.CancellationToken.ThrowIfCancellationRequested();
            loadNsMember(subMember, rootNamespace);
          }

          rootNamespace
        }

        def timer = Stopwatch.StartNew();

        this.CancellationToken.ThrowIfCancellationRequested();

        def asm = unit.Assembly;
        def isCoreLib = CciHost.CoreAssemblySymbolicIdentity.Equals(asm.AssemblyIdentity);
        when (isCoreLib)
          ClearSystemTypes();

        def loadedSymbols = List();
        def rootNamespace = loadDotNetSymbols(asm, context, loadedSymbols);

        when (isCoreLib)
          InitSystemTypes(context, rootNamespace);

        assert2(_singleDimensionArray != null);
        assert2(_cciObject != null);
        assert2(_objectSymbol != null);
        assert2(_cciInternedKeyToSymbolMap != null);
        assert2(_cciInternedKeyToGenericSymbolMap != null);

        InitBaseTypeSet(context, loadedSymbols);

        def loadNitraSymbols(asm : IAssembly, rootNamespace, project : Project) : void
        {
          def file = AssemblyFile(project, asm);
          def source = file.GetSource();
          def reader = Nitra.Serialization2.MetadataReader(project, source);
          def resourceRefOpt = UnitHelper.FindResourceNamed(asm, _nitraMetadataStreamName);
          when (resourceRefOpt != null)
          {
            def data = resourceRefOpt.Resource.Data.ToArray();
            def metadataStream = MemoryStream(data, false);
            try reader.ReadRoot(rootNamespace, metadataStream)
            catch { e => throw ApplicationException($"Load symbols from '$file' failed. Exception: $(e.Message)", e); }
          }
        }

        loadNitraSymbols(asm, rootNamespace, project);

        this.CancellationToken.ThrowIfCancellationRequested();

        unit.SetRootNamespace(rootNamespace);

        Debug.WriteLine($<#LoadLib("$asm") took: $(timer.Elapsed)#>);
      }

      DefineCSharpAliases(corelibRootNamespace : NamespaceSymbol, context : DotNetDependentPropertyEvalContext) : NamespaceSymbol
      {
        def aliasesNamespace = NamespaceSymbol();
        aliasesNamespace.DeclaredIn  = null;
        aliasesNamespace.FullName    = "";
        aliasesNamespace.EvalProperties(context);

        def bindNs(scope : Scope, name : string) : Ref[NamespaceSymbol]
        {
          //assert2(false);
          def res = Reference(Location.Default, name).Bind.[NamespaceSymbol](scope);
          assert2(!res.IsUnresolved);
          assert2(!res.IsAmbiguous);
          assert2(res.Symbols.Length == 1);
          res
        }
        def bindType(scope : Scope, name : string) : Ref[TopGenericTypeSymbol]
        {
          //assert2(false);
          def res = Reference(Location.Default, name).Bind.[TopGenericTypeSymbol](scope);
          assert2(!res.IsUnresolved);
          assert2(!res.IsAmbiguous);
          assert2(res.Symbols.Length == 1);
          res
        }
        def systemNsRef = bindNs(corelibRootNamespace.Scope, "System");
        def defineAlias(context : DotNetDependentPropertyEvalContext, systemNs : NamespaceSymbol, declaredIn : NamespaceSymbol, name : string, aliasName : string) : void
        {
          def symbolRef  = bindType(systemNs.Scope, name);
          unless (symbolRef.IsSymbolEvaluated)
            return;

          def symbol     = symbolRef.Symbol;
          def decl       = symbol.FirstDeclarationOrDefault :> IExternalTopTypeDeclaration;
          def aliasDecl  = ExternalTopTypeDeclaration.[TypeAliasSymbol](Name(Location.Default, aliasName), decl.Type);
          def alias      = aliasDecl.DefineSymbol(declaredIn.MemberTable);
          alias.Replacement = symbolRef;
          alias.TypeParametersCount = 0;
          alias.TypeParameters      = ImmutableArray.Empty;
          alias.DeclaredIn          = declaredIn;
          alias.EvalProperties(context);
        }

        when (systemNsRef.IsSymbolEvaluated)
        {
          def systemNs = systemNsRef.Symbol;

          defineAlias(context, systemNs, aliasesNamespace, "Object",  "object");
          defineAlias(context, systemNs, aliasesNamespace, "Void",    "void");
          defineAlias(context, systemNs, aliasesNamespace, "String",  "string");
          defineAlias(context, systemNs, aliasesNamespace, "Boolean", "bool");
          defineAlias(context, systemNs, aliasesNamespace, "Byte",    "byte");
          defineAlias(context, systemNs, aliasesNamespace, "SByte",   "sbyte");
          defineAlias(context, systemNs, aliasesNamespace, "Int16",   "short");
          defineAlias(context, systemNs, aliasesNamespace, "UInt16",  "ushort");
          defineAlias(context, systemNs, aliasesNamespace, "Int32",   "int");
          defineAlias(context, systemNs, aliasesNamespace, "UInt32",  "uint");
          defineAlias(context, systemNs, aliasesNamespace, "Int64",   "long");
          defineAlias(context, systemNs, aliasesNamespace, "UInt64",  "ulong");
          defineAlias(context, systemNs, aliasesNamespace, "Single",  "float");
          defineAlias(context, systemNs, aliasesNamespace, "Double",  "double");
          defineAlias(context, systemNs, aliasesNamespace, "Decimal", "decimal");
          defineAlias(context, systemNs, aliasesNamespace, "Char",    "char");
        }

        aliasesNamespace
      }

      MakeTypeParameters(context : DotNetDependentPropertyEvalContext, symbol : GenericEntitySymbol, cciType : ITypeDefinition) : void
      {
        unless (symbol.IsTypeParametersCountEvaluated)
          symbol.TypeParametersCount = cciType.GenericParameterCount;
        unless (symbol.IsTypeParametersEvaluated)
          symbol.TypeParameters = CreateGenericParameters(cciType.GenericParameterCount, cciType.GenericParameters, context);
      }

      public LoadCustomAttribute(cciCustomAttribute : ICustomAttribute, context : DotNetDependentPropertyEvalContext) : CustomAttributeSymbol
      {
        def customAttributeSymbol = CustomAttributeSymbol();
        def attrType = CciTypeToTypeSymbol(cciCustomAttribute.Type, context);
        customAttributeSymbol.Type = attrType;
        customAttributeSymbol.FullName = attrType.FullName;
        def cciCtorKey = cciCustomAttribute.Constructor.InternedKey;
        def filter(sym : Member.ConstructorSymbol) : bool
        {
          def decl = sym.GetDeclarationsOfType.[ExternalConstructorDeclaration]().FirstOrDefault();
          when (decl == null)
            return false;

          decl.Method.InternedKey == cciCtorKey
        }
        def result = attrType.Scope.Bind(filter);
        when (result.HasResult)
          customAttributeSymbol.Constructor = result.GetSymbols().First();

        def cciArgToCustomAttributeExpression(cciExpr : IMetadataExpression) : CustomAttributeExpression
        {
          | c is IMetadataConstant =>
            match (c.Value)
            {
              | v is bool   => CustomAttributeExpression.Bool  (v)
              | v is byte   => CustomAttributeExpression.Byte  (v)
              | v is char   => CustomAttributeExpression.Char  (v)
              | v is double => CustomAttributeExpression.Double(v)
              | v is float  => CustomAttributeExpression.Float (v)
              | v is int    => CustomAttributeExpression.Int   (v)
              | v is long   => CustomAttributeExpression.Long  (v)
              | v is sbyte  => CustomAttributeExpression.Sbyte (v)
              | v is short  => CustomAttributeExpression.Short (v)
              | v is string => CustomAttributeExpression.String(v)
              | v is uint   => CustomAttributeExpression.Uint  (v)
              | v is ulong  => CustomAttributeExpression.Ulong (v)
              | v is ushort => CustomAttributeExpression.Ushort(v)
              | _ => assert(false);
            }

          | a is IMetadataCreateArray =>
            def elemType = CciTypeToTypeSymbol(a.ElementType, context);
            def elems = a.Initializers.MapToArray(cciArgToCustomAttributeExpression);
            CustomAttributeExpression.Array(elemType, elems)

          | t is IMetadataTypeOf => CustomAttributeExpression.Type(CciTypeToTypeSymbol(t.Type, context))
          | _ => assert2(false); assert(false)
        }
        customAttributeSymbol.Arguments = cciCustomAttribute.Arguments.MapToArray(cciArgToCustomAttributeExpression);
        def cciNamedArgToCustomAttributeExpression(a : IMetadataNamedArgument) : CustomAttributeNamedArgument
        {
          def expr = cciArgToCustomAttributeExpression(a.ArgumentValue);
          def nameId = StringIndex.GetId(a.ArgumentName.Value); // TODO: ns.Name.UniqueKey
          CustomAttributeNamedArgument(nameId, expr)
        }
        customAttributeSymbol.NamedArguments = cciCustomAttribute.NamedArguments.MapToArray(cciNamedArgToCustomAttributeExpression);

        def name   = NRB.Name(NoLocation, customAttributeSymbol.Name); // TODO: ns.Name.UniqueKey
        customAttributeSymbol.AddDeclaration(ExternalCustomAttributeDeclaration(name, cciCustomAttribute));
        customAttributeSymbol.EvalProperties(context);
        customAttributeSymbol
      }

      public Dispose() : void
      {
        when ((CciHost : object) is IDisposable as d)
          d.Dispose();
      }

      MakeModifiers(visibility : TypeMemberVisibility) : Modifiers
      {
        mutable modifiers;
        when (visibility == TypeMemberVisibility.Private)
          modifiers |= Modifiers.Private;
        when (visibility == TypeMemberVisibility.Public)
          modifiers |= Modifiers.Public;
        when (visibility == TypeMemberVisibility.FamilyOrAssembly)
          modifiers |= (Modifiers.Protected | Modifiers.Internal);
        when (visibility == TypeMemberVisibility.Family)
          modifiers |= Modifiers.Protected;
        modifiers
      }

      internal LoadParameters(paremeters : Seq[IParameterDefinition], containingScope : TableScope, context : DotNetDependentPropertyEvalContext) : void
      {
        foreach (p in paremeters)
        {
          //FormalParameter
          def parameterName = Name(NoLocation, p.Name.Value); // TODO: type.Name.UniqueKey
          def parameter = ExternalParameterDeclaration(parameterName, p).DefineSymbol(containingScope);
          parameter.Type = CciTypeToTypeSymbol(p.Type, context);
          mutable parameterModifier;
          when (p.IsOut)
            parameterModifier |= ParameterModifier.Out;
          when (p.IsByReference)
            parameterModifier |= ParameterModifier.Ref;
          when (p.IsParameterArray)
            parameterModifier |= ParameterModifier.Params;
          parameter.Modifier = parameterModifier;
          parameter.Index = p.Index;
          parameter.EvalProperties(context);
        }
      }

      internal LoadTypeMembers(member : ITypeDefinitionMember, declaredIn : ContainerSymbol, context : DotNetDependentPropertyEvalContext) : DeclarationSymbol
      {
        def visibility = member.Visibility;

        //when (visibility != TypeMemberVisibility.Public && visibility != TypeMemberVisibility.Family && visibility != TypeMemberVisibility.FamilyOrAssembly)
        //  return;

        def makeStaticIf(isStatic : bool, flags : ModifierSet) : void { when (isStatic) flags.Add(Modifiers.Static) }
        def name = Name(NoLocation, member.Name.Value); // TODO: type.Name.UniqueKey
        def flags = ModifierSet(context);
        flags.Add(MakeModifiers(visibility));

        def symbol : DeclarationSymbol =
          match (member)
          {
            | m is IPropertyDefinition =>
              makeStaticIf(m.IsStatic, flags);
              def prop = ExternalPropertyDeclaration(name, m).DefineSymbol(declaredIn.MemberTable);
              prop.Flags = flags;
              unless (prop.IsDeclaredInEvaluated)
                prop.DeclaredIn = declaredIn :> GenericContainerTypeSymbol;
              prop.Type = CciTypeToTypeSymbol(m.Type, context);
              prop

            | m is IMethodDefinition when m.IsConstructor =>
              def method = ExternalConstructorDeclaration(name, m).DefineSymbol(declaredIn.MemberTable);
              makeStaticIf(m.IsStatic, flags);
              method.Flags = flags;
              unless (method.IsDeclaredInEvaluated)
                method.DeclaredIn = declaredIn :> GenericContainerTypeSymbol;
              method.EvalProperties(context);
              LoadParameters(m.Parameters, method.ParameterScope, context);
              method

            | m is IMethodDefinition   =>
              makeStaticIf(m.IsStatic, flags);
              def method = ExternalMethodDeclaration(name, m).DefineSymbol(declaredIn.MemberTable);
              method.Flags = flags;

              unless (method.IsDeclaredInEvaluated)
                method.DeclaredIn = declaredIn :> GenericContainerTypeSymbol;
              unless (method.IsTypeParametersCountEvaluated)
                method.TypeParametersCount = m.GenericParameterCount;
              unless (method.IsTypeParametersEvaluated)
                method.TypeParameters = CreateGenericParameters(m.GenericParameterCount, m.GenericParameters, context);

              method.ReturnType = CciTypeToTypeSymbol(m.Type, context);
              method.EvalProperties(context);

              LoadParameters(m.Parameters, method.ParameterScope, context);
              method

            | m is IFieldDefinition    =>
              if (member.ContainingTypeDefinition.IsEnum)
              {
                def field = ExternalEnumFieldDeclaration(name, m).DefineSymbol(declaredIn.MemberTable);
                //field.Flags = flags;
                unless (field.IsDeclaredInEvaluated)
                  field.DeclaredIn = declaredIn :> EnumSymbol;
                field
              }
              else
              {
                makeStaticIf(m.IsStatic, flags);

                when(m.IsReadOnly)
                  flags.Add(Modifiers.Readonly);

                def field = ExternalFieldDeclaration (name, m).DefineSymbol(declaredIn.MemberTable);
                field.Flags = flags;
                unless (field.IsDeclaredInEvaluated)
                  field.DeclaredIn = declaredIn :> GenericContainerTypeSymbol;;
                field.Type = CciTypeToTypeSymbol(m.Type, context);
                field
              }

            | m is IEventDefinition    =>
              def evnt = ExternalEventDeclaration   (name, m).DefineSymbol(declaredIn.MemberTable);
              unless (evnt.IsDeclaredInEvaluated)
                evnt.DeclaredIn = declaredIn :> GenericContainerTypeSymbol;
              evnt.Type = CciTypeToTypeSymbol(m.Type, context);
              evnt

            | _ => assert(false)
          };

          when (symbol is CustomAttributeHostDeclarationSymbol as attrHost)
            attrHost.CustomAttributes = LazyAttributeList(member, this, context);

          symbol.EvalProperties(context);
          symbol
      }

      CciTypeToTypeSymbol(cciTypeReference : ITypeReference, context : DotNetDependentPropertyEvalContext) : TypeSymbol
      {
        match (cciTypeReference)
        {
          | t is IGenericTypeParameter =>
            def typeInfo = CciTypeToTypeSymbol(t.DefiningType, context) :> GenericTypeSymbol;
            def tp = typeInfo.TypeParameters[t.Index];
            tp

          | t is IArrayTypeReference =>
            def args = ImmutableArray.Create(CciTypeToTypeSymbol(t.ElementType, context));
            def typeInfo =
              if (t.IsVector)
                _singleDimensionArray : ArraySymbol
              else
              {
                def a = MultiDimensionArraySymbol();
                a.TypeParametersCount = 0;
                a.Rank        = t.Rank;
                //a.LowerBounds = t.LowerBounds.ToArray();
                //a.Sizes       = t.Sizes.ToArray();
                a.EvalProperties(context);
                a
              };
            def constructedType = TopConstructedTypeSymbol();
            constructedType.TypeInfo = typeInfo;
            constructedType.Args = args;
            constructedType.EvalProperties(context);
            //constructedType.Scope = typeInfo.Scope;
            constructedType

          | t is ITypeDefinition =>
            mutable typeSymbol;
            if (_cciInternedKeyToSymbolMap.TryGetValue(t.InternedKey, out typeSymbol))
            {
              typeSymbol
            }
            else
            {
              // the type definition not found
              _objectSymbol
            }

          | t is IGenericTypeInstanceReference =>
            _cciInternedKeyToGenericSymbolMap.GetOrAdd(cciTypeReference.InternedKey, _key => {
              def typeInfo = CciTypeToTypeSymbol(t.GenericType, context) :> GenericTypeSymbol;
              def args = t.GenericArguments.Select(CciTypeToTypeSymbol(_, context)).ToImmutableArray();
              def name = Name(NoLocation, t.GenericType.Name.Value);
              def constructedType = ExternalConstructedTypeDeclaration.[TopConstructedTypeSymbol] (name, t.ResolvedType).DefineSymbol(null);

              constructedType.TypeInfo = typeInfo;
              constructedType.Args = args;
              constructedType.EvalProperties(context);
              constructedType
            });
          | _ =>
            //resolvs++;
            mutable typeSymbol;

            if (_cciInternedKeyToSymbolMap.TryGetValue(cciTypeReference.InternedKey, out typeSymbol))
            {
              //resolvedByKey++;
              typeSymbol
            }
            else
            {
              _objectSymbol
            }
        }
      }

      CreateGenericParameters(genericParameterCount : ushort, genericParams : Seq[IGenericParameter], context : DotNetDependentPropertyEvalContext) : ImmutableArray[TypeParameterSymbol]
      {
        if (genericParameterCount == 0)
          ImmutableArray.Empty
        else
        {
          def result = ImmutableArray.CreateBuilder(genericParameterCount : int);
          foreach (tp in genericParams with i)
          {
            def name  = NRB.Name(NoLocation, tp.Name.Value); // TODO: type.Name.UniqueKey
            def tps   = TypeParameterDeclaration(name, tp).DefineSymbol();
            tps.EvalProperties(context);
            result.Add(tps);
          }
          result.MoveToImmutable()
        }
      }

      MakeArrayTypeParameter(context : DotNetDependentPropertyEvalContext) : TypeParameterSymbol
      {
        def name  = NRB.Name(NoLocation, "T");
        def tps   = ArrayTypeParameterDeclaration(name).DefineSymbol();
        tps.EvalProperties(context);
        tps
      }

      ClearSystemTypes() : void
      {
        _cciInternedKeyToSymbolMap.Clear();
        _cciInternedKeyToGenericSymbolMap.Clear();
        _assemblyToNodeMap.Clear();

        _singleDimensionArray = null;
        _cciObject            = null;
        _objectSymbol         = null;
      }

      InitSystemTypes(context : DotNetDependentPropertyEvalContext, rootNamespace : NamespaceSymbol) : void
      {
        def textName             = "#Array1";
        def name                 = Name(NoLocation, textName); // TODO: type.Name.UniqueKey
        def cciType              = CciHost.PlatformType.SystemArray. ResolvedType;
        def singleDimensionArray = ExternalTopTypeDeclaration.[SingleDimensionArraySymbol] (name, cciType).DefineSymbol(rootNamespace.MemberTable);
        def modifiers            = ModifierSet(context);
        modifiers.Add(Modifiers.Public);
        singleDimensionArray.DeclaredIn          = rootNamespace;
        singleDimensionArray.Flags               = modifiers;
        singleDimensionArray.FullName            = textName;
        singleDimensionArray.TypeParametersCount = 1;
        singleDimensionArray.TypeParameters      = ImmutableArray.Create(MakeArrayTypeParameter(context));
        //singleDimensionArray.BaseTypeSet // TODO: fill with array interfaces
        singleDimensionArray.EvalProperties(context);
        _singleDimensionArray = singleDimensionArray;

        def cciObject = CciHost.PlatformType.SystemObject.ResolvedType;
        _cciObject = cciObject;
        def ok = _cciInternedKeyToSymbolMap.TryGetValue(cciObject.InternedKey, out _objectSymbol);
        assert2(ok, "System.Object not loaded yet!");

        AliasesNamespace = DefineCSharpAliases(rootNamespace, context);
      }

      InitBaseTypeSet(context : DotNetDependentPropertyEvalContext, loadedSymbols : List[DeclarationSymbol]) : void
      {
        when (_objectSymbol == null)
          return;
        def timer = Stopwatch.StartNew();
        mutable resolvs = 0;
        mutable resolvedByKey = 0;
        mutable resolvedByResolvedTypeProp = 0;

        foreach (x in loadedSymbols)
        {
          def decl = x.FirstDeclarationOrDefault :> IExternalTypeDeclaration;
          when (decl == null)
            continue;

          def cciType = decl.Type;
          match (x)
          {
            | en is EnumSymbol => en.UnderlyingType = CciTypeToTypeSymbol(cciType.UnderlyingType, context);
            | type is SupportsInheritanceTypeSymbol =>
              def baseTypeSet = BaseTypeReferenceSet(context);
              type.BaseTypeSet = baseTypeSet;
              foreach (cciBaseClasse in cciType.BaseClasses)
              {
                def typeSymbol = CciTypeToTypeSymbol(cciBaseClasse, context);
                baseTypeSet.AddParent(typeSymbol);
              }
              foreach (cciInterface in cciType.Interfaces)
              {
                def typeSymbol = CciTypeToTypeSymbol(cciInterface, context);
                baseTypeSet.AddParent(typeSymbol);
              }

            | _ => ()
          }
        }

        context.NextPass();

        foreach (x in loadedSymbols)
        {
          x.EvalProperties(context);

          when ((x : DeclarationSymbol) is ContainerSymbol as containerSymbol)
            unless (containerSymbol.IsScopeEvaluated)
              x.Scope = containerSymbol.MemberTable;
        }

        Debug.WriteLine($"InitBaseTypeSet took: $(timer.Elapsed) resolvs=$resolvs, resolvedByKey=$resolvedByKey, resolvedByResolvedTypeProp=$resolvedByResolvedTypeProp");
      }
    }
  }

  [Record]
  public class ExternalNamespaceDeclaration : ExternalDeclaration[NamespaceSymbol]
  {
    public Namespace : INamespaceDefinition { get; private set; }
    public override CreateSymbol() : DeclarationSymbol { NamespaceSymbol() }
  }

  public interface IExternalTypeDeclaration
  {
    Type : ITypeDefinition { get; }
  }

  public interface IExternalTopTypeDeclaration
  {
    Type : INamespaceTypeDefinition { get; }
  }

  public interface IExternalNestsdTypeDeclaration
  {
    Type : INestedTypeDefinition { get; }
  }

  interface IArrayDeclaration
  {
    Type : IArrayType { get; }
  }

  [Record]
  public class ExternalTopTypeDeclaration[TSymbol] : ExternalDeclaration[TSymbol], IExternalTopTypeDeclaration, IExternalTypeDeclaration
    where TSymbol : DeclarationSymbol
  {
    public Type : INamespaceTypeDefinition { get; private set; }
  }

  [Record]
  public class ExternalConstructedTypeDeclaration[TSymbol] : ExternalDeclaration[TSymbol], IExternalTypeDeclaration
    where TSymbol : DeclarationSymbol
  {
    public Type : ITypeDefinition { get; private set; }
  }

  [Record]
  public class ExternalNestsdTypeDeclaration[TSymbol] : ExternalDeclaration[TSymbol], IExternalNestsdTypeDeclaration, IExternalTypeDeclaration
    where TSymbol : DeclarationSymbol
  {
    public Type : INestedTypeDefinition { get; private set; }
  }

  [Record]
  public class TypeParameterDeclaration : ExternalDeclaration[TypeParameterSymbol]
  {
    public TypeParam : IGenericParameter;
    public override CreateSymbol() : DeclarationSymbol { TypeParameterSymbol() }
  }

  [Record]
  public class ArrayTypeParameterDeclaration : ExternalDeclaration[TypeParameterSymbol]
  {
    public override CreateSymbol() : DeclarationSymbol { TypeParameterSymbol() }
  }

  [Record]
  public class ExternalPropertyDeclaration : ExternalDeclaration[Member.PropertySymbol]
  {
    public Property : IPropertyDefinition;
    public override CreateSymbol() : DeclarationSymbol { Member.PropertySymbol() }
  }

  [Record]
  public class ExternalMethodDeclaration : ExternalDeclaration[Member.MethodSymbol]
  {
    public Method : IMethodDefinition;
    public override CreateSymbol() : DeclarationSymbol { Member.MethodSymbol() }
  }

  [Record]
  public class ExternalConstructorDeclaration : ExternalDeclaration[Member.ConstructorSymbol]
  {
    public Method : IMethodDefinition;
    public override CreateSymbol() : DeclarationSymbol { Member.ConstructorSymbol() }
  }

  [Record]
  public class ExternalFieldDeclaration : ExternalDeclaration[Member.FieldSymbol]
  {
    public Field : IFieldDefinition;
    public override CreateSymbol() : DeclarationSymbol { Member.FieldSymbol() }
  }

  [Record]
  public class ExternalEnumFieldDeclaration : ExternalDeclaration[EnumMemberSymbol]
  {
    public Field : IFieldDefinition;
    public override CreateSymbol() : DeclarationSymbol { EnumMemberSymbol() }
  }

  [Record]
  public class ExternalEventDeclaration : ExternalDeclaration[Member.EventSymbol]
  {
    public Event : IEventDefinition;
    public override CreateSymbol() : DeclarationSymbol { Member.EventSymbol() }
  }

  [Record]
  public class ExternalParameterDeclaration : ExternalDeclaration[FormalParameterSymbol]
  {
    public Parameter : IParameterDefinition;
    public override CreateSymbol() : DeclarationSymbol { FormalParameterSymbol() }
  }

  [Record]
  public class ExternalCustomAttributeDeclaration : ExternalDeclaration[CustomAttributeSymbol]
  {
    public Attribute : ICustomAttribute;
    public override CreateSymbol() : DeclarationSymbol { CustomAttributeSymbol() }
  }
}
